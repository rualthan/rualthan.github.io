---
layout: post
title: Jenkins
---

[Jenkins](https://www.jenkins.io) is an open source automation software. It automates the various phases of software development.
- Build
- Test
- Deployment/Delivery 

# Table of Contents
- [CI/CD](#cicd)
- [Install Jenkins](#install-jenkins)
- [First job](#first-job)
- [Copy job](#copy-job)
- [Linking jobs/Pipeline](#linking-jobs)
- [Trigger build from GitHub](#trigger-build-from-github)
- [Deploy Java App to Tomcat](#deploy-java-app-to-tomcat)
- [Archive artifact](#archive-artifact)
- [Copy artifact](#copy-artifact)
- [Java App pipeline](#java-app-pipeline)
- [Jenkins cluster](#jenkins-cluster)
- [Scheduling](#scheduling)
- [Execute script on remote host]

## CI/CD
### Continuous Integration (CI)
- CI is the practice of frequently integrating code from multiple developers. 
- Every commit or push to a central repository triggers automated build and test.
- Build/Test failure triggers an alert to developers.

### Continuous Delivery (CD)
- A practice where code changes are automatically built, tested, and prepared for a release to production. 
- Requires manual approval before deployment.

### Continuous Deployment (CD)
- A practice where code changes are automatically built, tested, and deployed to production. 

## Install Jenkins
1. Jenkins can be deployed as [container or java](https://www.jenkins.io/doc/book/installing/) WAR but I will install it using the old fashioned way on Ubuntu 22.04 using the package manager. I follow the [instructions](https://www.jenkins.io/doc/book/installing/linux/#debianubuntu) on Jenkins website. 

1. Jenkins has two releases - Weekly release and LTS release. I will use the LTS release.

1. It requires Java. I will install Java 21 which is compatible with the latest LTS (2.479.1 October 2024) at the time of writing this.

1. Install Java
    ```
    sudo apt update -y
    sudo apt install fontconfig openjdk-21-jre -y
    ```

    Verify
    ```
    java -version
    openjdk version "21.0.8" 2025-07-15
    OpenJDK Runtime Environment (build 21.0.8+9-Ubuntu-0ubuntu122.04.1)
    OpenJDK 64-Bit Server VM (build 21.0.8+9-Ubuntu-0ubuntu122.04.1, mixed mode, sharing)
    ```

1. Add Jenkins repository
    ```
    sudo wget -O /etc/apt/keyrings/jenkins-keyring.asc \
    https://pkg.jenkins.io/debian-stable/jenkins.io-2023.key
    echo "deb [signed-by=/etc/apt/keyrings/jenkins-keyring.asc]" \
    https://pkg.jenkins.io/debian-stable binary/ | sudo tee \
    /etc/apt/sources.list.d/jenkins.list > /dev/null
    sudo apt update -y
    ```
1. Install Jenkins
    ```
    sudo apt install jenkins -y
    ```

    Enable and start Jenkins
    ```
    sudo systemctl --now jenkins
    ```

    Verify
    ```
    sudo systemctl status jenkins
    ```

    Jenkins should ve available at http://localhost:8080. 

    To change the default port 8080 to some other port, edit the following file and restart Jenkins
    ```
    grep 8080   /usr/lib/systemd/system/jenkins.service
    Environment="JENKINS_PORT=8080"
    ```
    The Jenkins config file and parameter to edit may change. 
1. Get the admin password from `/var/lib/jenkins/secrets/initialAdminPassword`
1. Go to http://locahost:8080
1. Follow the on screen steps
1. Jenkins is ready

## First Job
1. Go to Jenkins
1. New Item
1. Provide a name: Job1
1. Freestyle project
1. Build Steps
    1. Execute shell
    1. Command: echo "My first Jenkins job"
1. Save
1. Build Now
1. Go to Console Output to see the output

## Copy job
To use an existing job as the basis for a new job, we can copy it.

1. In Jenkins > New Item 
1. Provide a job name: Job2 
1. Scroll down > Copy from 
1. Enter the source job: Job1
1. Customize the job
1. Or save it and customize later

## Linking jobs
We can link jobs and create a dependency chain.  This way, the success of a job can automatically start a sequence of subsequent jobs, automating workflows by linking build, test, and deployment stages. 

- Upstream jobs are projects that trigger other jobs
- Downstream jobs are the projects that are triggered by the upstream job.


1. Lets make another copy of the First Job and name it Job3.
1. We will link them such that the success of Job1 triggers Job2 and Job3: Job1 > Job2 > Job3
1. Go to Job1 > Configure 
    1. Add post-build action
    1. Build other projects
    1. Projects to build: Job2
    1. Save
    1. Go to Status, you will see Job2 under Downstream Projects. Likewise, in Job2 Status, you will see Job1 is the upstream project.
1. Go to Job3 > Configure
    1. Triggers
    1. Build after other projects are built
    1. Projects to watch: Job2
    1. Status page of Job2 and Job3 will show the respective Downstream and Upstream projects.

Trigger a build of Job1 and observe the chain reaction. Inspect the build of Job2 and Job3 and notice how the build was triggered.

To visually see this linkage between the jobs and review it as a single unit, we can create a pipeline.

1. Install the plugin Build Pipeline
1. In Jenkins, to to the home page
1. Click the + sign next to All
    1. Name: pipeline1
    1. Type: Build Pipeline View
    1. Create
    1. In Pipeline Flow > Select Initial Job> Job1
    1. Save
    1. You should see the pipeline
1. Click Run to start the pipeline
1. The jobs should run serially starting from Job1. Successful jobs will turn green. Refresh the page if there are no changes. 

## Trigger build from GitHub 
We can trigger Jenkins build from GitHub using Webhook. In this section, we will do the following:
1. Configure GitHub and Jenkins integration using webhook
1. Make change from GitHub

Configure the integration
1. In Jenkins > Manage Jenkins (the gear icon) > System > GitHub > Advance > Override Hook URL
1. Jenkins runs on my local host. GitHubs won't be able to access it. To expose Jenkins to the internet, I use ngrok.
1. Get ngrok url for Jenkins
    ```
    ngrok http 8080
    ```
    Copy the ngrok URL `https://example.ngrok-free.app`
1. Go to your GitHub repository > Settings > Webhooks
1. In Payload URL, paste the ngrok url and append github-webook, don't miss the trailing slash: `https://example.ngrok-free.app/github-webhook/`
1. Add webhook

Create a Jenkins Job
1. New Item > Enter a name > Freestyle project > OK
1. Source Code Management > Git
1. Enter the repository htts url under Repository URL
1. Branches to build > main
1. Triggers > GitHub hook trigger for GITScm polling
1. Save
1. To test > Build Now

Trigger build from GitHub
1. Go to the GitHub repository 
1. Edit some file and commit
1. This should trigger a build. In Jenkins, if you don't see a new build, refresh the page.
1. Click on the build, you should see "Started by GitHub push by user_name".

This is **Continuous Integration**.

We made a commit from GitHub GUI. Let us know commit with git CLI

1. Clone the repository
    ```
    git clone URL
    ```
1. cd <DIR>
1. Make some change
1. git add . && git commit -m "message"
1. In Jenkins > Go to the job
1. There should be a new build
1. Open the build. Inspect the status, changes and Console Output.


Modern IDEs such as VS Code has integrations with git/GitHub.We can commit and push changes from VS Code itself.

1. Open the repository in VS Code
2. Make some changes
2. Go the Source Control
2. Enter a commit message and click Commit
2. To push to remote, click Sync Changes
2. In Jenkins, go to the job and inspect the latest build.

## Deploy Java App to Tomcat
We will do a one click deployment of  Java App to Tomcat. We will need maven to build the java App as well. 

The Vagrant file I use for this setup is available here: [cicd-jenkins-tomcat](https://github.com/rualthan/vagrantfiles/tree/main/cicd-jenkins-tomcat). It has Jenkins running at 8080 and two instances of Tomcat, 8090(lets call it staging) and 9090 (prod).


1. We first need to find the install directory of Maven and Java. 
    ```
    which mvn
    /opt/maven/bin/mvn

    readlink -f $(which java)
    /usr/lib/jvm/java-17-openjdk-arm64/bin/java
    ```
    These are the paths to the binaries. The install directory will be `/opt/maven` and `/usr/lib/jvm/java-17-openjdk-arm64/`.

1. Since we want Jenkins to build Java code, it has to know where java and maven are installed. 
   In Jenkins > Go to Manage Jenins > Tools
    - Java installations > Add JDK
    - Name: Java17
    - JAVA_HOME:/usr/lib/jvm/java-17-openjdk-arm64/ 
    - Maven Installations > Add Maven
    - Name: Maven3.8.8
    - MAVEN_HOME:/opt/maven/

1. In Jenkins, install the plugin Deploy to Container. We need this to deploy a  WAR file to Tomcat.
1. In GitHub, fork this https://github.com/PythonAwsBoto3/webapp

We are ready to create a job in Jenkins.
1. New Item > Provide a Name > Freestyle Project
1. Source Code Management > Git > Provide the repository URL
1. Build Steps > Add build step >Invoke top-level Maven targets >
    - Maven Version: Maven3.8.8
    - Goals: package
    - Maven has 7 lifestyles and package is one of them. It packages the compiled code into its distributable format (e.g., a JAR or WAR file). 

1. Post-build Actions > Add post-build action > Deploy war/ear to a container 
    - WAR/EAR files:**/*.war
    - Containers > Add Container > Tomcat 9x
    - Add the Tomcat credentials
    - Add Tomcat URL. For me, it is http://localhost:8090
1. Build Now

If the build is successful.

- Go to Tomcat
- Manager App
- Click on /mvn-hello-world
- Your App is deployed

Lets change the job to automatically trigger a new build when there's a change in the source code.

1. Open the job in Jenkins > Configure > Triggers > Poll SCM
1. It uses cron syntax for schedule. For our example, I will use "* * * * *" for Jenkins to check the repository every minute.
1. In the repository, open webapp/src/main/webapp/index.jsp
1. Make some change.
1. This should trigger the job in the next 1 minute in Jenkins.
1. Once the job ran, check the outcome in <tomcat_url>/mvn-hello-world.

So what's happening here? We take a source code, build it and then deploy. This is **Continuous Deployment**. Of course, we don't have a test step here.

## Archive artifact
In this section, we will take the source code, build it but stop short of deploying it. We will archive the artifact instead and keep it ready for deployment. This is **Continuous Delivery**.

Artifact is the tangible outcome of a software development process. It can be files, documents or even Docker images.


1. Copy the job created in the [previous section](#deploy-java-app-to-tomcat).
1. Open the job > Configure
1. Delete the "Deploy war/ear to a container"  section.
1. Add post-build action > Archive the artifacts
1. Files to archive: **/*.war
1. Build Now
1. Go Workspace > job_name > target
1. Locate the artifact mvn-hello-world.war

## Copy artifact
We can have a job make use of the artifact generated by other jobs. Let's use the artifact created by the [Archive artifact](#archive-artifact) job and deploy it to our staging Tomcat instance running on port 8090.

1. Go to Jenkins > Manage > Jenkins > Plugins
1. Available plugins > Install Copy Artifact plugin
1. Create a new Freestyle job
1. Build Steps > Copy artifacts from another project 
1. Project Name: Enter the source job name
1. Which build: Latest successful build
1. Artifacts to copy: **/*.war
1. Post-build Actions > Add post-build action > Deploy war/ear to a container 
    - WAR/EAR files:**/*.war
    - Containers > Add Container > Tomcat 9x
    - Add the Tomcat credentials
    - Add Tomcat URL. This time, it will be http://localhost:9090
1. Save
1. Build Now

If the build is successful.

- Go to Tomcat, staging instance: http://localhost:8090
- Manager App
- Click on /mvn-hello-world
- Your App is deployed

## Java App pipeline
We will create a build pipeline to build, deploy to staging and then to production.
1. Copy the job created [here](#archive-artifact) as package
2. Copy the job created [here](#-copy-artifact) as deploy-to-staging. 
2. Make another copy as deploy-to-prod.
3. Configure package job
    1. Add post-build action
    1. Build other projects
    1. Projects to build: deploy-to-stagin
3. Configure deploy-to-staging job
    1. Add post-build action
    1. Build other projects (manual step)
    1. Scroll up to find to this action
    1. Downstream Project Names: deploy-to-prod
    1. In the Post-build Actions, ensure it is going to staging instance running port 8090.
3. Configure deploy-to-prod job
    1. In the Post-build Actions, ensure it is going to prod instance running port 9090.
4. In Jenkins home page, add a new view by clicking on + sign
    1. Name: build-staging-prod
    2. Type: Build Pipeline View
    3. Create
    4. Under Pipeline Flow, Select Initial Job: package

5. Run the pipeline
6. The pipeline will run up to deploy-to-staging since we configured deploy-to-prod to require a manual step(Continuous Delivery).
7. Trigger the deploy-to-prod manually.

## Jenkins cluster
So far, we have been using Jenkins in a standalone mode. Like any modern software, Jenkins can scale out to keep up with more workload.

My Vagrantfile for this setup is available [here](https://github.com/rualthan/vagrantfiles/blob/main/jenkins-cluster/Vagrantfile). Review that Vagrantfile. The agent node requires Java which is added as part of the box initialization. SSH key pairs for jenkins user is also created.

1. Configure key based SSH between the controller and agent node. In vagrant, I actually name them master and worker.
    1. A key pair is generated for jenkins user in the controller as a part of `vagrant up`. 
    1. SSH to the controller and copy the pub key available at  /var/lib/jenkins/.ssh/id_rsa.pub
    1. SSH to the agent node
        ```
        sudo su - jenkins
        mkdir -p ~/.ssh
        chmod 700 ~/.ssh
        echo "PASTE_THE_PUBLIC_KEY_STRING_HERE" >> ~/.ssh/authorized_keys
        chmod 600 ~/.ssh/authorized_keys
    1. The controller should be able to SSH to the agent node without password. SSH to the controller. 
        ```
        sudo su - jenkins
        ssh -i /var/lib/jenkins/.ssh/id_rsa <AGENT NODE IP>
1. Open the controller IP in a browser and perform the initial setup.
1. Lets add node credentials
    1. Manage Jenkins > Credentials
    1. Click on (global) under Domains
    1. Add credentials
    1. Kind: SSH Username with private key
    1. Description: node1
    1. Username: jenkins
    1. Copy the private key from the controller at /var/lib/jenkins/.ssh/id_rsa and paste it here.
    1. Create
1. Lets add the node
    1. Manage Jenkins > Nodes
    1. New node
    1. Node name: node1
    1. Type: Permanent Agent
    1. Remote root directory:/home/jenkins
    1. Launch method: Launch agents via SSH
    1. Host: <Agent node IP>
    1. Credentials: Select jenkins(node1), you can also add the credentials from this if you have not added it before. 
    1. Save

1. Create a job
    1. Name: Job1
    2. Type: FreeStyle Project
    3. Build Steps > Execute Shell
    3. Enter: sleep 10; echo "Jenkins"
    3. Save
1. Create a copy of Job1 as Job2. 
1. In Job2 > General > Restrict where this project can be run
    1. Label Expression: Node1
    1. Save
1. Go to Jenkins home page. You should see the two jobs listed.
1. Trigger both the jobs
1. Look at the Build Executor Status on the left and observe where the jobs run. Built-in-Node is the controller node.





