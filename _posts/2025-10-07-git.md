---
layout: post
title: Git
---

# Table of Contents
- [tldr](#tldr)
- [What is Git?](#what-is-git)
- [What is GitHub?](#github)
- [Install Git](#install-git)
- [Git config](#git-config)
- [.gitignore](#gitignore)
- [What is a git repository?](#git-repository)
- [The command to always run](#git-status)
- [Create a repository](#create-a-repository)
- [Basic workflow](#basic-workflow)
- [What to commit?](#what-to-commit)
- [Commit message](#commit-message)
- [Git log](#git-log)
- [States of files](#file-states)
- [Git project areas](#git-project-areas)
- [Git basics, behind the scenes](#git-basics-behind-the-scenes)
- [Need for staging](#need-for-staging)
- [Remote](#remote)
- [pull, fetch and push](#pull-fetch-push)
- [Branching](#branching)
- [Merging]
- [Merge conflict]
- [Rebase]
- [Cherrypick](#cherry-pick)
- [git init inside a repo]
- [Inside the .git directorty]
- [mv, rm a staged file]
- [mv, rm a committed file]
- [Git only for source code]


## tldr

- Git is a Distributed Version Control System written by Linus Torvalds in 2005.

- Git is a software whereas Github, GitLab etc. are hosted git service.

- Check git version
    ```
    git --version
    git -v
    ```

- Two ways to create a repository. 
    - Convert a local dir into a git repository
    - Clone an existing repository from somewhere.

- A file in a git repository can be in three states:
    - untracked 
    - modified
    - staged
    - comitted

- There are three areas in a git project: 
    - Working Directory
    - Staging Area (Index)
    - Local repository

- Git config to set on a new system before git init or git clone.
    ```
    git config --global user.name "John Doe"
    git config --global user.email johndoe@example.com
    git config --global core.editor emacs
    git config --global init.defaultBranch main
    git config --list
    ```

- .gitignore - Create this file in our repository. 
Add a list of files and directory you want git to ignore.

- Git basic workflow:
    - vi filename
    - git add filename
    - git commit -m "add filename"
    - git push 


- To check the status of files in the repository.
    ```
    git status
    ``` 

- Check git history
    ```
    git log
    git log --oneline
    ```

- Check current branch
    ```
    git branch
    ```

- Create new branch
    ```
    git branch branch_name
    ```

- Switch to different branch
    ```
    git checkout branch_name
    git switch branch
    ```

- Create new branch and switch to it
    ```
    git checkout -b branch_name
    git switch -c branch_name
    ```

- Merge a branch to main
    ```
    git checkout -b feature
    make changes
    stage and commit
    git checkout main
    git merge feature
    ```

- Clone a repository
    ```
    git clone URL
    ```

    This creates the directory, initilizes it and files in the repository are checked out to the working dir 

- Pair an existing local repository with remote and push it
    ```
    git remote add origin URL
    git push -u origin main
    ```

- Diff between commit
    ```
    git diff 9686bb8 e6de8d6
    ```

- Diff between branch
    ```
    git diff master..footer
    ```

## What is Git
Git a distributed version control system(DCVS). It was written by Linus Torvalds, the creator of Linux in 2005. But why did Linus took time to create it?

From the [Git website](https://git-scm.com/book/en/v2/Getting-Started-A-Short-History-of-Git):
>During the early years of the Linux kernel maintenance (1991–2002), changes to the software were passed around as patches and archived files. In 2002, the Linux kernel project began using a proprietary DVCS called BitKeeper.
>
>In 2005, the relationship between the community that developed the Linux kernel and the commercial company that developed BitKeeper broke down, and the tool’s free-of-charge status was revoked. This prompted the Linux development community (and in particular Linus Torvalds, the creator of Linux) to develop their own tool based on some of the lessons they learned while using BitKeeper.

As a distributed VCS:
- Every developer has full repo   
- Commits & branches locally      
- Merge/push to remote later 


### A list of major SCM/VCS softwares:

| SCM / VCS           | Type                 | Years Active          | Notes |
|---------------------|--------------------|---------------------|-------|
| **RCS**             | Centralized         | 1982 – present      | Early file-based version control, mainly for single files. |
| **CVS**             | Centralized         | 1986 – 2000s        | Popular for open-source projects; weak branching support. |
| **Perforce**        | Centralized         | 1995 – present      | High-performance, enterprise-grade, handles large repos. |
| **Subversion (SVN)**| Centralized         | 2000 – present      | Replaced CVS in many places; better branching and atomic commits. |
| **BitKeeper**       | Distributed (DVCS)  | 1998 – 2005 (Linux kernel) | Proprietary; early DVCS used by Linux kernel before Git. |
| **Monotone**        | Distributed (DVCS)  | 2003 – present      | Open-source DVCS; cryptographic commits; limited adoption. |
| **Git**             | Distributed (DVCS)  | 2005 – present      | Created by Linus Torvalds; fast, distributed, excellent branching. |
| **Mercurial**       | Distributed (DVCS)  | 2005 – present      | Similar to Git; simpler CLI; used by some large projects. |


## GitHub
Git is a software. [GitHub](https://github.com/) is a Microsoft owned hosted git repository. It is a cloud bsaed service based on git. There are similar other services such as: 
- GitLab
- Bitbucket
- Azure Repos
- AWS CodeCommit
- Gitea (self-hosted)
- Gerrit (self-hosted)

## Install Git
For Debian based distro such as Ubuntu:

```
sudo apt install git  -y
git --version
git version 2.34.1
```

Google it for other distro or OS. 

## Git config
If you are setting up git for the first time on your system, perform the following configuration.

Setup your identity. This is used by git in your commit log to record who performs the changes.
```
git config --global user.name "John Doe"
git config --global user.email johndoe@example.com
```

Configure your preferred editor. Git will open this when it needs you to type a message. The default is vim.
```
git config --global core.editor emacs
```

For every new repository, by default git creates a branch called master. The one considered more politically correct is called main. To change the default branch name:
``` 
git config --global init.defaultBranch main
```

Show the config
```
git config --list
user.name=John Doe
user.email=johndoe@example.com
core.editor=emacs
init.defaultbranch=main
```

Where are these stored?
```
cat ~/.gitconfig
[user]
	name = John Doe
	email = johndoe@example.com
[core]
	editor = emacs
[init]
	defaultBranch = main
```

### Why use `--global`?
We use the `--global` flag to use the config for all projects. If you need, you can configure a per project config by running the same commands  without the --global flag.

Example:
```
cd project
git config --global user.name "JD"
```

The commit log on this repository will use JD instead of John Doe. 

## Gitignore
There may be some files and dirs in your profect you do not want or need git to track. To instruct git to ignore these, create a .gitignore file and populate it with the list of files and dirs.

Example: 
```
cd project
mkdir secret
touch file1 file2 secret/file3
```

Git tells me all of these are untracked.
```
git status
On branch main

No commits yet

Untracked files:
  (use "git add <file>..." to include in what will be committed)
	file1
	file2
	secret/
```

To stop git from tracking file and secret dir:
```
vi .gitignore
cat .gitignore
file1
secret/
```

Git stops tracking them:
```
git status
On branch main

No commits yet

Untracked files:
  (use "git add <file>..." to include in what will be committed)
	.gitignore
	file2

nothing added to commit but untracked files present (use "git add" to track)
```

Depending on the type of your project, there may be many files you do not need to track and you may not know them all. You can use .gitignore generators to generate a .gitignore file. Google ".gitignore generator"

## Git repository
A git repository is a directory tracked by git for changes.

This is a git repository:
```
git status
On branch main

No commits yet

nothing to commit (create/copy files and use "git add" to track)

ls -la
total 12
drwxrwxr-x 3 vagrant vagrant 4096 Oct  7 17:20 .
drwxr-x--- 8 vagrant vagrant 4096 Oct  7 17:19 ..
drwxrwxr-x 7 vagrant vagrant 4096 Oct  7 17:20 .git
```

This is not a git repository:
```
git status
fatal: not a git repository (or any of the parent directories): .git

ls -la
total 8
drwxrwxr-x 2 vagrant vagrant 4096 Oct  7 17:19 .
drwxr-x--- 8 vagrant vagrant 4096 Oct  7 17:19 ..
```

## Create a repository
There are two ways to create a git repository
- Take a local dir and convert it into a Git repository
- Clone a Git repository from somewhere

### Convert local dir into a Git repository
```
#Go to the directory
cd project

#Check if it's a repository already
git status
fatal: not a git repository (or any of the parent directories): .git

#Initialize the directory
git init
Initialized empty Git repository in /home/vagrant/newdir/.git/

#This is now a git repository
#Note the presence of the hidden .git dir
ls -la
total 12
drwxrwxr-x  3 vagrant vagrant 4096 Oct  7 17:50 .
drwxr-x--- 10 vagrant vagrant 4096 Oct  7 17:49 ..
drwxrwxr-x  7 vagrant vagrant 4096 Oct  7 17:50 .git
```
### Clone a git repository from somewhere
```
#git clone <URL>
git clone https://github.com/libgit2/libgit2
Cloning into 'libgit2'...
remote: Enumerating objects: 129408, done.
remote: Counting objects: 100% (129408/129408), done.
remote: Compressing objects: 100% (35355/35355), done.
remote: Total 129408 (delta 91950), reused 129397 (delta 91942), pack-reused 0 (from 0)
Receiving objects: 100% (129408/129408), 70.45 MiB | 9.10 MiB/s, done.
Resolving deltas: 100% (91950/91950), done.

#Go into the libgit2 directory
cd libgit2/
git status
On branch main
Your branch is up to date with 'origin/main'.

nothing to commit, working tree clean

#List the dir
ls -la
total 208
drwxrwxr-x 16 vagrant vagrant  4096 Oct  7 17:55 .
drwxr-x--- 11 vagrant vagrant  4096 Oct  7 17:55 ..
-rw-rw-r--  1 vagrant vagrant   267 Oct  7 17:55 api.docurium
-rw-rw-r--  1 vagrant vagrant  1328 Oct  7 17:55 AUTHORS
drwxrwxr-x  3 vagrant vagrant  4096 Oct  7 17:55 ci
-rw-rw-r--  1 vagrant vagrant  2741 Oct  7 17:55 .clang-format
drwxrwxr-x  2 vagrant vagrant  4096 Oct  7 17:55 cmake
-rw-rw-r--  1 vagrant vagrant  6232 Oct  7 17:55 CMakeLists.txt
-rw-rw-r--  1 vagrant vagrant 64631 Oct  7 17:55 COPYING
drwxrwxr-x  8 vagrant vagrant  4096 Oct  7 17:55 deps
...
```
Cloning is a way to get a copy of an existing repository. The following happens when we clone libgit2 from https://github.com/libgit2/libgit2:
- It creates the directory libgit2
- It initializes the .git directory inside it
- It pulls down all the data from that repository
- It checks out the files into your working area

## Basic workflow

Create a new repository
```
mkdir project
cd project/
git init
```

Add, edit files
```
touch file1 file2 file3
vi file1
```

Stage the changes
```
git add .
# Using . will add all changes
```

Commit the changes
```
commmit -m "add file1,2,3"
```
## What to commit
A commit should contain single change, single task. If it is a bugfix for example, the commit should contain only changes related to that bug.

## Commit message
The commit message should short and meaningful. It should be written in an imperative form, like it is a command.
Examples
- "Add file instead" of "File added" or "Added file"
- "Fix bug#101 instead" of "Bug#101 fixed" or "Fixed bug#101" 

## Git log
To the see history changes in a repository, we use `git log`.

Lets repeat the basic workflow above and check the history


Create a new repository
```
mkdir project
cd project/
git init
```
There won't be any log before the first commit.
```
git log
fatal: your current branch 'main' does not have any commits yet
```

Add, edit files
```
touch file1 file2 file3
vi file1
```

Stage the changes
```
git add .
# Using . will add all changes
```

Commit the changes
```
commmit -m "add file1,2,3"
```

Now lets check the log
```
git log
commit 2d21a7db673d52a34a7de92f3dd30c6b00d6ed97 (HEAD -> main)
Author: John Doe <johndoe@example.com>
Date:   Wed Oct 8 13:10:40 2025 +0530
```

A shorter version
```
git log --oneline
2d21a7d (HEAD -> main) add file1,2,3
```

Lets run `git log` on diferent repo with lots of history
```
git log --oneline
9996a32 (HEAD -> master) update git
e6a6a75 add git tldr section first draft
e2298d4 add git
e70425f update first post
0693c58 (origin/master, origin/HEAD) Update post
969bd31 Update post
4303077 Update post
57277b4 Update post
d953f4f update post
e0725f2 added first post - getting it up
954ddc9 Update _config.yml
12cb8a2 Merge pull request #993 from italohdc/master
824a230 Permalink on 404.md
...
```

## File states
A file in a git repository can be in three states:
- untracked 
- modified
- staged
- comitted

Lets go into an existing repository 
```
cd project/
```

Create a new file
```
touch file
```

Check the status
```
git status
On branch main

No commits yet

Untracked files:
  (use "git add <file>..." to include in what will be committed)
	file

nothing added to commit but untracked files present (use "git add" to track)
```

The new file, which is file we created is not tracked by git. Lets ask git to track it by staging it.
```
git status
On branch main

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
	new file:   file
```

Now it is staged and ready to be committed.
```
git commit -m "add file"
[main (root-commit) d39d327] add file
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 file

git status
On branch main
nothing to commit, working tree clean
```
The file is committed and there are now no uncomitted work.

Lets edit the file and see what happens.
```
echo modified >> file

git status
On branch main
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   file

no changes added to commit (use "git add" and/or "git commit -a")
```

Git knows the file has been modified and we can proceed with the usual steps of `git add ...` and `git commit..`

## Git project areas
Closely aligned with the states a file can be in, there are three areas of git project: 
- Working Directory
- Staging Area (Index)
- Local repository

### Working Directory
You create and edit files in the working area. These are the files in the repository that you see. 
```
touch file
```


### Staging Area (Index)
You pick the changes that you want to save permanently into the repository and move them to a temporary area called staging or Index. 
```
git add file
```

### Local repository
Finally, when you commit the staged changes with the `git commit` command, the changes are said to be committed (saved) to the repository which is the local project directory on your system.
```
git commit -m "committ messsage"
```

## Git basics, Behind the scenes

Lets create a new repository.
```
mkdir project
cd project
git init
```

The directory is initialized. We have a .git directory.
```
ls -a
.  ..  .git
```

We have these in .git.
```
l -a .git/
./  ../  branches/  config  description  HEAD  hooks/  info/  objects/  refs/
```

Lets create a new file, which will be untracked.
```
touch file
git status
On branch main

No commits yet

Untracked files:
  (use "git add <file>..." to include in what will be committed)
	file

nothing added to commit but untracked files present (use "git add" to track)
```
Before staging the file, lets exam a few things.

.git/index file doesn't exist
```
ll .git/index
ls: cannot access '.git/index': No such file or directory
```

.git/objects has the following entries.
```
ll .git/objects/
total 16
drwxrwxr-x 4 vagrant vagrant 4096 Oct  8 11:11 ./
drwxrwxr-x 7 vagrant vagrant 4096 Oct  8 11:22 ../
drwxrwxr-x 2 vagrant vagrant 4096 Oct  8 11:11 info/
drwxrwxr-x 2 vagrant vagrant 4096 Oct  8 11:11 pack/
```

Now lets see what happens after staging the file.
```
git add file

ll .git/index
-rw-rw-r-- 1 vagrant vagrant 104 Oct  8 11:24 .git/index

ll .git/objects/
total 20
drwxrwxr-x 5 vagrant vagrant 4096 Oct  8 11:24 ./
drwxrwxr-x 7 vagrant vagrant 4096 Oct  8 11:24 ../
drwxrwxr-x 2 vagrant vagrant 4096 Oct  8 11:24 e6/
drwxrwxr-x 2 vagrant vagrant 4096 Oct  8 11:11 info/
drwxrwxr-x 2 vagrant vagrant 4096 Oct  8 11:11 pack/

ll .git/objects/e6/
total 12
drwxrwxr-x 2 vagrant vagrant 4096 Oct  8 11:24 ./
drwxrwxr-x 5 vagrant vagrant 4096 Oct  8 11:24 ../
-r--r--r-- 1 vagrant vagrant   15 Oct  8 11:24 9de29bb2d1d6434b8b29ae775ad8c2e48c5391
```
We see that .git/index now exists and there is a new folder e6 under .git/objects.

When we stage a file
- Git saves a snapshot of the file and store is as blob in .git/objects. In this case, the file "file" is saved under .git/objects/e6/.
- Git tracks the list of stages files in .git/index. 

We can see that as a zlib compressed data.
```
file  .git/objects/e6/9de29bb2d1d6434b8b29ae775ad8c2e48c5391
.git/objects/e6/9de29bb2d1d6434b8b29ae775ad8c2e48c5391: zlib compressed data
``` 

To prove that a snapshot is saved, lets delete the file in the working directory.
```
rm file
ll file
ls: cannot access 'file': No such file or directory
```

Can we still commit it?
```
git commit -m "add file"
[main (root-commit) c373546] add file
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 file
```

Yes, we can.
Lets bring it back to our working directory.

```
git checkout file
Updated 1 path from the index

ll file
-rw-rw-r-- 1 vagrant vagrant 0 Oct  8 11:32 file
```

To dive deeper into what happens when staging and committing:
- [Git Branching - Branches in a Nutshell](https://git-scm.com/book/en/v2/Git-Branching-Branches-in-a-Nutshell)
- [Git Internals - Git Objects](https://git-scm.com/book/en/v2/Git-Internals-Git-Objects)

- Ask ChatGPT:
    - "When happens during git committed"
    - "How is git commit ID computed"

## Need for staging
What is the need for staging? Why not directly commit?

- In our example, we have seen repositories with a few files only. In the real world, a repository will have hundreds of files. You may not keep track of the files you edit in your head. Hence, it would be better to select the list of files you have edited and keep them aside for commit. You get a chance to review what you stage before committing. I would think of this like a shopping cart. Would you like it if Amazon charges you the moment you add an item?

- To continue with the shopping cart example, if adding an item completes the transaction (lets imagine an auto pay of some sort is setup), I bet you would end up cancellation a whole lot of them. Similarly, if we were to directly commit with git, our git history will be full of restores or undos.

- When you are fully clear of what you want to do, there is an option to stage and commit in one step - `git commit -am "message"`. This works except for the first commit in a repository.

## Remote
What if everyone keeps a local repository on their system and there's no way to link your work with others, how would you collaborate? This where remote repository comes in.

In an enterprise, there will be a remote repository that is shared by all. There will be a dedicated team that owns and maintain it. Where I worked, it was maintained by a team called EngOps.

New Engineers will clone from the remote, add thier code and then pushes their changes to the remote repository.

The workflow would be something like this.
- Clone the remote 
- Make changes
- Stage and commit
- Push the changes to remote

Lets look into this with an example:

Clone a remote repository.
```
git clone https://github.com/rualthan/remote_repo.git
Cloning into 'remote_repo'...
remote: Enumerating objects: 3, done.
remote: Counting objects: 100% (3/3), done.
remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 (from 0)
Receiving objects: 100% (3/3), done.
```
- This creates a directory named remote_repo on my system. 
- It initializes the .git directory inside it
- It pulls down that data from the remote repository
- It checks out a working copy of the latest version

The repository has only one file README.md as we can see below.

```
cd remote_repo
ls -la
total 16
drwxrwxr-x  3 vagrant vagrant 4096 Oct  8 13:28 .
drwxr-x--- 13 vagrant vagrant 4096 Oct  8 13:28 ..
drwxrwxr-x  8 vagrant vagrant 4096 Oct  8 13:28 .git
-rw-rw-r--  1 vagrant vagrant   13 Oct  8 13:28 README.md
```

Lets edit, stage and commit it.
```
echo "learning remote" >> README.md
git add README.md
git commit -m "update README"
[main 5c22de0] update README
1 file changed, 1 insertion(+), 1 deletion(-)
```

Now, running `git clone` also sets up a remote for us.

```
git remote -v
origin	https://github.com/rualthan/remote_repo.git (fetch)
origin	https://github.com/rualthan/remote_repo.git (push)
```

Origin is the shortname for the url on the right side. This can be renamed or be named as you wish when setting up remote explicity.

The next task is to push the changes which we committed locally to the remote repository. This is done with the command `git push remote_name branch_name`

The remote name is origin and we want to push the main branch.

Lets push it.
```
git push -u origin main
Username for 'https://github.com':
```
We asked to provide credentials. Because we have not setup for us to be allowed by Github.

To keep things simple, I will use SSH keys along with SSH url. There are other [methods](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/about-authentication-to-github).

Setup key an SSH key based authentication by following [this](https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent). 


Switching to SSH url.
```
git remote -v
origin	https://github.com/rualthan/remote_repo.git (fetch)
origin	https://github.com/rualthan/remote_repo.git (push)

git remote set-url origin git@github.com:rualthan/remote_repo.git

git remote -v
origin	git@github.com:rualthan/remote_repo.git (fetch)
origin	git@github.com:rualthan/remote_repo.git (push)

```

After this, we should be able to push

```
git push -u origin main
Enumerating objects: 5, done.
Counting objects: 100% (5/5), done.
Writing objects: 100% (3/3), 265 bytes | 265.00 KiB/s, done.
Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 (from 0)
To https://github.com/rualthan/remote_repo.git
   da3eb69..9e74328  main -> main
branch 'main' set up to track 'origin/main'.
```

While cloning, if I use SSH url, then the remote would be setup with SSH url already. 
```
git clone git@github.com:rualthan/remote_repo.git
```

To review, when we clone a remote repository, it is auto-paired with the remote. Next, let's pair an existing local repository with a remote.

```
mkdir project
cd project/
git init
touch file
git add .
git commit -m "add file"
```

At this point, I have a clean status and no remote configured.
```
git status
On branch main
nothing to commit, working tree clean
(failed reverse-i-search)`crm': touch se^Cet/file3

git remote -v
```

Lets add a remote.
```
git remote add origin git@github.com:rualthan/remote_repo.git

git remote -v
origin	git@github.com:rualthan/remote_repo.git (fetch)
origin	git@github.com:rualthan/remote_repo.git (push)
```
But I will not be able to push yet because I have got pulled the existing data on the remote to my local. We will cover this in the next section.

### Why do we use -u with the push command?
```
git push -u origin main
```

This is to enable future push without supplying the arguments. Example:

```
cd remote_repo/
echo "learning remote is fun" >> README.md
git commit -am "update README"
[main db8640f] update README
 1 file changed, 1 insertion(+)
```

Now, lets push it with the remote and branch names.
```
git push
Enumerating objects: 5, done.
Counting objects: 100% (5/5), done.
Delta compression using up to 2 threads
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 287 bytes | 287.00 KiB/s, done.
Total 3 (delta 0), reused 0 (delta 0), pack-reused 0
To github.com:rualthan/remote_repo.git
   b1f1a05..db8640f  main -> main
```

## pull, fetch and push
Once we pair a local repository with remote by cloning or explicitly with `git remove add`, how do we sync data between the two? The answer is pull, fetch and push. Sync may not technically right term but it should give us the idea. 

Lets bring back the previous example where we could not push after adding a remote.

```
mkdir project
cd project/
git init
touch file
git add file
git commit -m "add file"
```
Adding remote.
```
git remote add origin git@github.com:rualthan/remote_repo.git
git remote -v
origin	git@github.com:rualthan/remote_repo.git (fetch)
origin	git@github.com:rualthan/remote_repo.git (push)
```

We have a clean status.
```
git status
On branch main
nothing to commit, working tree clean
```

Push fails.
```
git push -u origin main
To github.com:rualthan/remote_repo.git
 ! [rejected]        main -> main (fetch first)
error: failed to push some refs to 'github.com:rualthan/remote_repo.git'
hint: Updates were rejected because the remote contains work that you do
hint: not have locally. This is usually caused by another repository pushing
hint: to the same ref. You may want to first integrate the remote changes
hint: (e.g., 'git pull ...') before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details.
```

The reason:
>Updates were rejected because the remote contains work that you do not have locally.

To resolve this, we need to pull that work on the remote which we do not have locally.

But git pull too failed.
```
git pull origin main
From github.com:rualthan/remote_repo
 * branch            main       -> FETCH_HEAD
hint: You have divergent branches and need to specify how to reconcile them.
hint: You can do so by running one of the following commands sometime before
hint: your next pull:
hint:
hint:   git config pull.rebase false  # merge (the default strategy)
hint:   git config pull.rebase true   # rebase
hint:   git config pull.ff only       # fast-forward only
hint:
hint: You can replace "git config" with "git config --global" to set a default
hint: preference for all repositories. You can also pass --rebase, --no-rebase,
hint: or --ff-only on the command line to override the configured default per
hint: invocation.
fatal: Need to specify how to reconcile divergent branches.
```

I had to do fetch and rebase. 
```
git fetch origin
```
Fetch downloaded the data to the local but it will merge it. Sort of like, just download and park, don't open it.

As such, we don't see any new file in our working directory.
```
ls -la
total 12
drwxrwxr-x  3 vagrant vagrant 4096 Oct 11 08:41 .
drwxr-x--- 12 vagrant vagrant 4096 Oct 11 08:41 ..
-rw-rw-r--  1 vagrant vagrant    0 Oct 11 08:41 file
drwxrwxr-x  8 vagrant vagrant 4096 Oct 11 08:43 .git
```

To get the local to the same evel as remote, we need to merge or rebase. Merge didn't work, hence I rebased.
```
git rebase origin/main
Successfully rebased and updated refs/heads/main.
```

Now, we have a new file, README.md from the remote.
```
ls -la
total 16
drwxrwxr-x  3 vagrant vagrant 4096 Oct 11 08:44 .
drwxr-x--- 12 vagrant vagrant 4096 Oct 11 08:41 ..
-rw-rw-r--  1 vagrant vagrant    0 Oct 11 08:44 file
drwxrwxr-x  8 vagrant vagrant 4096 Oct 11 08:44 .git
-rw-rw-r--  1 vagrant vagrant   13 Oct 11 08:44 README.md
```
Finally, we will now be able to push from local to remote.

```
git push -u origin main
Enumerating objects: 4, done.
Counting objects: 100% (4/4), done.
Delta compression using up to 2 threads
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 271 bytes | 271.00 KiB/s, done.
Total 3 (delta 0), reused 0 (delta 0), pack-reused 0
To github.com:rualthan/remote_repo.git
   1a31381..1531fe8  main -> main
Branch 'main' set up to track remote branch 'main' from 'origin'.
```

I added a new file called file2 on the remote. Let us pull it.
```
git pull
remote: Enumerating objects: 4, done.
remote: Counting objects: 100% (4/4), done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 (from 0)
Unpacking objects: 100% (3/3), 935 bytes | 935.00 KiB/s, done.
From github.com:rualthan/remote_repo
   1531fe8..c97154c  main       -> origin/main
Updating 1531fe8..c97154c
Fast-forward
 file2 | 1 +
 1 file changed, 1 insertion(+)
 create mode 100644 file2
```

We now have file2.
```
ls -la
total 20
drwxrwxr-x  3 vagrant vagrant 4096 Oct 11 08:54 .
drwxr-x--- 12 vagrant vagrant 4096 Oct 11 08:41 ..
-rw-rw-r--  1 vagrant vagrant    0 Oct 11 08:44 file
-rw-rw-r--  1 vagrant vagrant    1 Oct 11 08:54 file2
drwxrwxr-x  8 vagrant vagrant 4096 Oct 11 08:54 .git
-rw-rw-r--  1 vagrant vagrant   13 Oct 11 08:44 README.md
```

So, what are fetch, pull and push.

- Fetch downloads data from the remote but does not do anything to the local. Your working directory is not untouched.
- Pull downloads data, merges it. It is fetch + merge. The files from remote that were not on local will be available in your working directory after pull
- Push sends your local commits to the remote. If the remote has commits from someone else that you do not have, git will reject it. You will first need to get your local on the same level as the remote first.

Both pull and push involves merging at the destination. If there is a conflict of some kind, we need to resolve that first. That is what I mean by bring it on the same level.

I am simplying it here by saying "same level". Git gurus may please excuse me for now.

We will talk about rebase later.

## Branching
To branch is to move off the path you were on. Trees branch out to capture more sunligth for food(photosynthesis). We exit the main road to head into a new direction.

We branch out a git project to morph it into something slightly different. May be to tryout some changes without disturbing the original progression.

A git repository is a series of changes (commits) joined together, the latest commit has pointer to the previous one. When we run `git init`, it creates a branch called master. This is often renamed to more political correct name which is main. If you create a new repository on Github, it will craete a branch called main. You can set a git config to name the default branch main. 

This is what a repository with just the default branch may look it. It has three commits.

(git init)--(initial commit/Add README)--(Add file1)--(Update README)


```
git log --oneline
a453f86 (HEAD -> main) Update README
a1c3fa8 Add file1
56cb273 Add README
```

The command `git log` shows us the commits. It also shows up we are in main branch.  Is there any other branch?

```
git branch
* main
```

No. We have main branch only and we are currently on it as indicated by the * sign. 

If you look up the `git log` output, the latest commit a453f86 (the top one) has "HEAD -> main". 

After adding a new commit (Add file2).
```
git log --oneline
4f4d970 (HEAD -> main) Add file2
a453f86 Update README
a1c3fa8 Add file1
56cb273 Add README
```
The HEAD and main moves with the latest commit. What are they - HEAD, main? Why are they moving?

They indicate our current location. They are pointers. Main is our only branch. So branch is a pointer poiting to the latest commit. We will get to HEAD shortly. 


Lets create a new branch.
```
git branch feature
```
There are two branches now but we are still in main.
```
git branch
  feature
* main
```

Checking `git log`.
```
git log --oneline
4f4d970 (HEAD -> main, feature) Add file2
a453f86 Update README
a1c3fa8 Add file1
56cb273 Add README
```

There are three pointers HEAD, main and feature attached to the latest commit f4d970/Add file2. 
Lets note the order "(HEAD -> main, feature)".

Switching the feature branch.
```
git checkout feature
Switched to branch 'feature'

git branch
* feature
  main

git log --oneline
4f4d970 (HEAD -> feature, main) Add file2
a453f86 Update README
a1c3fa8 Add file1
56cb273 Add README
```

We are in feature branch indicated by * sign, `git log` shows the same information except that the order is different "(HEAD -> feature, main)".

So what does this tell us? HEAD points to the current branch while branch points to the latest commit, our current location.

Right now, both the branches main and feature points to the same commit ID 4f4d970. This is because we haven't made any commit after creating a new branch. We have dediced to go in different direction but we haven't taken the next step. We are still at the intersection.

Before taking the next step, let me show you the working directories of both the branches.

main
```
git branch
  feature
* main

ls
file1  file2  README.md
```

feature
```
git checkout feature
Switched to branch 'feature'

ls
file1  file2  README.md
```

They have same files. This should be no surprise. So far, main and feature points to the main commit. Right now, they are exactly the same.

If anyone tells you a new branch gets a copy of the source branch. This is wrong. This may be true for other VCS where branch involves a copy of data to a new directory.

This is not so with Git. This is why they they say branch is fast, easy and cheap with Git. 

Even if you check the size of the project directory before and after creating a new branch, you will see a minimal increment only.

```
vagrant@vagrant:~/project$ du -sh .
280K	.
vagrant@vagrant:~/project$ git branch new
vagrant@vagrant:~/project$ git branch
* main
  new
vagrant@vagrant:~/project$ du -sh .
288K	.
```

Branch creation will only result in the addition of some metadata.


Now lets take the next step and start adding changes to feature branch.

```
git branch
* feature
  main

touch feature_file
git add .
git commit -m "Add feature_file"
```

Checking the log.
```
git log --oneline
e80c1e2 (HEAD -> feature) Add feature_file
4f4d970 (main) Add file2
a453f86 Update README
a1c3fa8 Add file1
56cb273 Add README
```

- feature moves to the commite 80c1e2
- HEAD points to feature because it is the current branch
- main remains with 4f4d970 

main stood still while feature moves ahead. Lets add file3 to main.
```
git checkout main
Switched to branch 'main'

touch file3
git add .
git commit -m "Add file3"
```
Where is main?
```
git log --oneline
6274383 (HEAD -> main) Add file3
4f4d970 Add file2
a453f86 Update README
a1c3fa8 Add file1
56cb273 Add README
```

main moves to 6274383. What happened to the commit e80c1e2 we made in feature branch? Why don't we see it here. We shouldn't. That is now on a different branch or line. They- main, feature are now on their own path. The commonality ends at 4f4d970. 

Will they meet again? It us up to us. We will see that in merging and rebase. 

### why checkout to switch a branch 
That is a good question. The checkout command was inherited from older VCS softwares. In those systems, checking out meant:
>“Give me the files from a specific revision or branch so I can work on them.”

With Git, you can checkout a branch, a commit-hash and file. This is confusing. A new command switch was introduced for switching to a branch.

Switch branch
```
git switch branch_name
```

Create branch and switch
```
git switch -c branch_name
```

The checkout equivalents.
```
git checkout branch_name
git checkout -b branch_name
```

### Why branch?
Lets get back to why branch? Why would we want to do it?

We will use a car manufacturing analagoy. For efficiency and optimization, Auto industry often create different cars using the same platform. Usually, similar body and engine but different body style. An SUV and a Sedan version off the same platform is all too common right now in India. 

It might look like this.
- Start with main branch which is the platform
- Add Chassis
- Add Engine
    - SUV
        - Add SUV body
    - Sedan
        - Add Sedan body
- Add Chassisv2
- Add Enginev2

The commonality ends after engine. I don't want to add the body in my main because the body is specific. The main is my platform, my blueprint. I don't want to mess it up. It should have only things that will be shared by both types.

I will improve the engine and chassis for my platformv2 from which I will branch out to my newer versions of SUV and Sedan in future.

For a software release, it would be something like:
- Add feature1
- Add feature2
    - release v1
- Add feature3
- Add feature1v2
- Add feature2v2

Once I have sufficient feature for my v1 release, I will cut a new branch for v1. Builds will be created off this branch and tested. Any changes specifci to v1 will be done in this branch only. Meanwhile, the main branch will go on with more features and improvements. At some point in future, a v2 release will branch off. 
 






















