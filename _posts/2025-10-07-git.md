---
layout: post
title: Git
---
The world does not need another guide. This is my effort to document and cement my learning on Git. Writing makes you think, a lot. It is a great way to self-check your learning. What I thought would need three days took me two weeks. In the end, it feels very rewarding and I am glad I took the journey.

# Table of Contents
- [tldr](#tldr)
- [Learning resources](#learning-resources)
- [What is Git?](#what-is-git)
- [What is GitHub?](#github)
- [Install Git](#install-git)
- [Git config](#git-config)
- [.gitignore](#gitignore)
- [What is a git repository?](#git-repository)
- [Create a repository](#create-a-repository)
- [Basic workflow](#basic-workflow)
- [Situational awareness](#situational-awareness)
- [What to commit?](#what-to-commit)
- [Commit message](#commit-message)
- [git log, git blame](#git-log-git-blame)
- [States of files](#file-states)
- [Git project areas](#git-project-areas)
- [Git basics, behind the scenes](#git-basics-behind-the-scenes)
- [Need for staging](#need-for-staging)
- [Remote](#remote)
- [pull, fetch and push](#pull-fetch-push)
- [Branching](#branching)
- [Merging](#merging)
- [Rebase](#rebase)
- [cherry-pick](#cherry-pick)
- [Stashing](#stashing)
- [Compare changes, git diff](#git-diff)
- [Restores, undo](#undos)
- [git init inside a repo](#git-init-again)
- [Exploring .git directory](#exploring-git-directory)
- [Rename and delete](#rename-and-delete)
- [Git alias](#git-alias)
- [Tagging](#tagging)
- [Git only for source code?](#other-use)
- [Git for backup people](#git-for-backup-people)
- [The HEAD and tape recorder](#the-head-and-tape-recorder)
- [Contributing to a project](#contributing-to-a-project)

## tldr

- Git is a Distributed Version Control System written by Linus Torvalds in 2005.

- Git is a software whereas Github, GitLab etc. are hosted git service.

- Version Control System (VCS) is a tool that records changes to a file or set of files over time we can recall specific versions later. 

- Fun fact: The word "git" is a British slang meaning an unpleasant or contemptible person. Linus humorously named it git. It is not uncommon for a FOSS project to have a playful and funny name. 


- Check git version
    ```
    git --version
    git -v
    ```

- Two ways to create a repository. 
    - Convert a local dir into a git repository (`git init`)
    - Clone an existing repository from somewhere.(`git clone URL`)

- A file in a git repository can be in one of these states:
    - untracked
    - modified, unstaged
    - modified, staged
    - committed

- There are three areas in a git project: 
    - Working Directory
    - Staging Area (Index)
    - Local repository

- Git config to set on a new system before git init or git clone.
    ```
    git config --global user.name "John Doe"
    git config --global user.email johndoe@example.com
    git config --global core.editor code --wait
    git config --global init.defaultBranch main
    git config --list
    ```

- .gitignore - Contains a list of files and directory we want git to ignore.

- Git basic workflow
    - project_dir/
    - vi filename
    - git add filename
    - git commit -m "add filename"
    - git push 


- To check the status of files in the repository.
    ```
    git status
    ``` 

- Check git history
    ```
    git log
    git log --oneline
    ```

- Check current branch
    ```
    git branch
    ```

- Create new branch
    ```
    git branch branch_name
    ```

- Switch to different branch
    ```
    git checkout branch_name
    git switch branch
    ```

- Create new branch and switch to it
    ```
    git checkout -b branch_name
    git switch -c branch_name
    ```

- Merge a branch to main
    ```
    git checkout -b feature
    make changes
    stage and commit
    git checkout main
    git merge feature
    ```

- Clone a repository
    ```
    git clone URL
    ```

    This creates the directory, initializes it and files in the repository are checked out to the working dir 

- Pair an existing local repository with remote and push it
    ```
    git remote add origin URL
    git push -u origin main
    ```

- Diff between commit
    ```
    git diff 9686bb8 e6de8d6
    ```

- Diff between branch
    ```
    git diff master..footer
    ```


## Learning resources
For any topic, there is ever a single material that covers everything or explains them all to your satisfaction. There's always something which someone explains better the others. 

These are the resources I used for learning git.
- I had an initial introduction to git from a [course](https://www.devopsacademy.co/) I took offline.
- I watched the freeCodeCamp video [Learn Git – Full Course for Beginners](https://www.youtube.com/watch?v=zTjRZNkhiEU&t=11925s) on Youtube, twice! I took notes along the second time. Hitesh is awesome! He is a great teacher.
- The [materials on git website](https://git-scm.com/learn) are pretty good.
    - [Pro Git book](https://git-scm.com/book/en/v2) for Git internals
    - [The official tutorial](https://git-scm.com/docs/gittutorial) is indeed short and sweet 
    - [Git Immersion](https://gitimmersion.com/) with 53 short and sweet labs. It was a bit hit when it was [posted at HN](https://news.ycombinator.com/item?id=2104872) in 2012. 
    - [Cheat Sheet](https://git-scm.com/cheat-sheet) if you need it.
    - Of course, AI


## What is Git
Git a distributed version control system(DVCS). It was written by Linus Torvalds, the creator of Linux in 2005. But why did Linus took time to create it?

From the [Git website](https://git-scm.com/book/en/v2/Getting-Started-A-Short-History-of-Git):
>During the early years of the Linux kernel maintenance (1991–2002), changes to the software were passed around as patches and archived files. In 2002, the Linux kernel project began using a proprietary DVCS called BitKeeper.
>
>In 2005, the relationship between the community that developed the Linux kernel and the commercial company that developed BitKeeper broke down, and the tool’s free-of-charge status was revoked. This prompted the Linux development community (and in particular Linus Torvalds, the creator of Linux) to develop their own tool based on some of the lessons they learned while using BitKeeper.

As a distributed VCS:
- Every developer has full repo   
- Commits & branches locally      
- Merge/push to remote later 


A list of major SCM/VCS softwares:

| SCM / VCS           | Type                 | Years Active          | Notes |
|---------------------|--------------------|---------------------|-------|
| **RCS**             | Centralized         | 1982 – present      | Early file-based version control, mainly for single files. |
| **CVS**             | Centralized         | 1986 – 2000s        | Popular for open-source projects; weak branching support. |
| **Perforce**        | Centralized         | 1995 – present      | High-performance, enterprise-grade, handles large repos. |
| **Subversion (SVN)**| Centralized         | 2000 – present      | Replaced CVS in many places; better branching and atomic commits. |
| **BitKeeper**       | Distributed (DVCS)  | 1998 – 2005 (Linux kernel) | Proprietary; early DVCS used by Linux kernel before Git. |
| **Monotone**        | Distributed (DVCS)  | 2003 – present      | Open-source DVCS; cryptographic commits; limited adoption. |
| **Git**             | Distributed (DVCS)  | 2005 – present      | Created by Linus Torvalds; fast, distributed, excellent branching. |
| **Mercurial**       | Distributed (DVCS)  | 2005 – present      | Similar to Git; simpler CLI; used by some large projects. |


## GitHub
Git is a software. [GitHub](https://github.com/) is a Microsoft owned hosted git repository. It is a cloud based service based on git. There are other similar services such as: 
- GitLab
- Bitbucket
- Azure Repos
- AWS CodeCommit

You can self host a git repository using
- Gitea 
- Gerrit

## Install Git
For Debian based distribution such as Ubuntu:

```
sudo apt install git  -y
git --version
git version 2.34.1
```

It's `yum install git` for RedHat derivatives and `brew install git` on Mac.Google the instruction for other distributions or OS.    

## Git config
If you are setting up git for the first time on your system, perform the following configuration.

Setup your identity. This is used by git in your commit log to record who performs the changes.
```
git config --global user.name "John Doe"
git config --global user.email johndoe@example.com
```

Configure your preferred editor. Git will open this when it needs you to type a message. The default is vim.
```
git config --global core.editor code --wait
```

For every new repository, by default git creates a branch called master. The one considered more politically correct is called main. To change the default branch name:
``` 
git config --global init.defaultBranch main
```

Show the config
```
git config --list
user.name=John Doe
user.email=johndoe@example.com
core.editor=emacs
init.defaultbranch=main
```

Where are these stored?
```
cat ~/.gitconfig
[user]
	name = John Doe
	email = johndoe@example.com
[core]
	editor = emacs
[init]
	defaultBranch = main
```

### Why use `--global`?
We use the `--global` flag to use the config for all projects. If you need, you can configure a per project config by running the same commands  without the `--global` flag.

Example:
```
cd project
git config user.name "JD"
```

The commit log on this repository will use JD instead of John Doe. 

## Gitignore
There may be some files or directories in your project you do not want or need git to track. To instruct git to ignore these, create a .gitignore file and enter the list to ignore.

Example: 
```
cd project
mkdir secret
touch file1 file2 secret/file3
```

Git tells me all of these are untracked.
```
git status
On branch main

No commits yet

Untracked files:
  (use "git add <file>..." to include in what will be committed)
	file1
	file2
	secret/
```

To stop git from tracking file1 and secret dir:
```
vi .gitignore
cat .gitignore
file1
secret/
```

Git stops tracking them:
```
git status
On branch main

No commits yet

Untracked files:
  (use "git add <file>..." to include in what will be committed)
	.gitignore
	file2

nothing added to commit but untracked files present (use "git add" to track)
```

Depending on the type of your project, there may be many files you do not need to track and you may not know them all. You can use .gitignore generators to generate a .gitignore file. Google ".gitignore generator".

You can use wildcards to create a patters. To ignore all files with .tmp extension, use `*.tmp`.

## Git repository
A git repository is a directory tracked by git for changes.

This is a git repository:
```
cd project/
git status
On branch main

No commits yet

nothing to commit (create/copy files and use "git add" to track)

ls -la
total 12
drwxrwxr-x 3 vagrant vagrant 4096 Oct  7 17:20 .
drwxr-x--- 8 vagrant vagrant 4096 Oct  7 17:19 ..
drwxrwxr-x 7 vagrant vagrant 4096 Oct  7 17:20 .git
```

This is not a git repository:
```
cd project2/
git status
fatal: not a git repository (or any of the parent directories): .git

ls -la
total 8
drwxrwxr-x 2 vagrant vagrant 4096 Oct  7 17:19 .
drwxr-x--- 8 vagrant vagrant 4096 Oct  7 17:19 ..
```

## Create a repository
There are two ways to create a git repository
- Take a local directory and convert it into a Git repository
- Clone a Git repository from somewhere

### Convert local dir into a Git repository
```
#Go to the directory
cd project

#Check if it's a repository already
git status
fatal: not a git repository (or any of the parent directories): .git

#Initialize the directory
git init
Initialized empty Git repository in /home/vagrant/newdir/.git/

#This is now a git repository
#Note the presence of the hidden .git dir
ls -la
total 12
drwxrwxr-x  3 vagrant vagrant 4096 Oct  7 17:50 .
drwxr-x--- 10 vagrant vagrant 4096 Oct  7 17:49 ..
drwxrwxr-x  7 vagrant vagrant 4096 Oct  7 17:50 .git
```
### Clone a git repository from somewhere
```
#git clone <URL>
git clone https://github.com/libgit2/libgit2
Cloning into 'libgit2'...
remote: Enumerating objects: 129408, done.
remote: Counting objects: 100% (129408/129408), done.
remote: Compressing objects: 100% (35355/35355), done.
remote: Total 129408 (delta 91950), reused 129397 (delta 91942), pack-reused 0 (from 0)
Receiving objects: 100% (129408/129408), 70.45 MiB | 9.10 MiB/s, done.
Resolving deltas: 100% (91950/91950), done.

#Go into the libgit2 directory
cd libgit2/
git status
On branch main
Your branch is up to date with 'origin/main'.

nothing to commit, working tree clean

#List the dir
ls -la
total 208
drwxrwxr-x 16 vagrant vagrant  4096 Oct  7 17:55 .
drwxr-x--- 11 vagrant vagrant  4096 Oct  7 17:55 ..
-rw-rw-r--  1 vagrant vagrant   267 Oct  7 17:55 api.docurium
-rw-rw-r--  1 vagrant vagrant  1328 Oct  7 17:55 AUTHORS
drwxrwxr-x  3 vagrant vagrant  4096 Oct  7 17:55 ci
-rw-rw-r--  1 vagrant vagrant  2741 Oct  7 17:55 .clang-format
drwxrwxr-x  2 vagrant vagrant  4096 Oct  7 17:55 cmake
-rw-rw-r--  1 vagrant vagrant  6232 Oct  7 17:55 CMakeLists.txt
-rw-rw-r--  1 vagrant vagrant 64631 Oct  7 17:55 COPYING
drwxrwxr-x  8 vagrant vagrant  4096 Oct  7 17:55 deps
...
```
Cloning is a way to get a copy of an existing repository. The following happens when we clone libgit2 from https://github.com/libgit2/libgit2:
- It creates the directory libgit2
- It initializes the .git directory inside it
- It pulls down all the data from that repository
- It checks out the files into your working area

## Basic workflow

Create a new repository
```
mkdir project
cd project/
git init
```

Add, edit files
```
touch file1 file2 file3
vi file1
```

Stage the changes
```
git add .
# Using . will add all changes
```

Commit the changes
```
commmit -m "add file1,2,3"
```
## Situational awareness
These are the commands to run to get a git situational awareness. 

- `git status`
  - Is the directory initialized? 
  - Have I staged the changes I made?
  - Do I have uncommitted changes?
- `git branch`
  - What is my current branch?
  - What are the branches available?
- `git log, got log --oneline`
  - Where am I, where is my HEAD?
  - Give me a SITREP 

## What to commit
A commit should contain single change, single task. If it is a bugfix for example, the commit should contain only changes related to that bug.

## Commit message
The commit message should short and meaningful. It should be written in an imperative form, like it is a command.
Examples
- "Add file instead" of "File added" or "Added file"
- "Fix bug#101 instead" of "Bug#101 fixed" or "Fixed bug#101"
- To add additional description, leave a space after the first line.  

## Git log
To the see history changes in a repository, we use `git log`.

Lets repeat the basic workflow above and check the history


Create a new repository
```
mkdir project
cd project/
git init
```
There won't be any log before the first commit.
```
git log
fatal: your current branch 'main' does not have any commits yet
```

Add, edit files
```
touch file1 file2 file3
vi file1
```

Stage the changes
```
git add .
# Using . will add all changes
```

Commit the changes
```
commit -m "add file1,2,3"
```
Staging and committing in one step 
```
git commit -am "message"
```
This will automatically stage known files, files that were previously committed. It will not work for new files.


Now lets check the log
```
git log
commit 2d21a7db673d52a34a7de92f3dd30c6b00d6ed97 (HEAD -> main)
Author: John Doe <johndoe@example.com>
Date:   Wed Oct 8 13:10:40 2025 +0530
```

A shorter version
```
git log --oneline
2d21a7d (HEAD -> main) add file1,2,3
```

`git log` on a different repository with lots of history
```
git log --oneline
9996a32 (HEAD -> master) update git
e6a6a75 add git tldr section first draft
e2298d4 add git
e70425f update first post
0693c58 (origin/master, origin/HEAD) Update post
969bd31 Update post
4303077 Update post
57277b4 Update post
d953f4f update post
e0725f2 added first post - getting it up
954ddc9 Update _config.yml
12cb8a2 Merge pull request #993 from italohdc/master
824a230 Permalink on 404.md
...
```

To check who all worked on a file and when:
```
git blame file_name
```

## File states
A file in a git repository can be in three states:
- untracked: New file, never committed before 
- modified, unstaged: Updated since last commit but not staged
- modified, staged: Updated and staged
- committed: Committed and saved in repository

Lets go into an existing repository 
```
cd project/
```

Create a new file
```
touch file
```

Check the status
```
git status
On branch main

No commits yet

Untracked files:
  (use "git add <file>..." to include in what will be committed)
	file

nothing added to commit but untracked files present (use "git add" to track)
```

The new file we created is not tracked by git. Lets ask git to track it by staging it.
```
git add file

git status
On branch main

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
	new file:   file
```

Now it is staged and ready to be committed.
```
git commit -m "add file"
[main (root-commit) d39d327] add file
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 file

git status
On branch main
nothing to commit, working tree clean
```
The file is committed and there are now no uncommitted work.

Lets edit the file and see what happens.
```
echo modified >> file

git status
On branch main
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   file

no changes added to commit (use "git add" and/or "git commit -a")
```

Git knows the file has been modified.

## Git project areas
Closely aligned with the states a file can be in, there are three areas of git project: 
- Working Directory
- Staging Area (Index)
- Local repository

### Working Directory
You create and edit files in the working area. These are the files in the repository that you see. 
```
touch file
```


### Staging Area (Index)
You pick the changes that you want to save permanently into the repository and move them to a temporary area called staging or Index. 
```
git add file
```

### Local repository
Finally, when you commit the staged changes with the `git commit` command, the changes are said to be committed (saved) to the repository.
```
git commit -m "commit message"
```

## Git basics, behind the scenes

Lets create a new repository.
```
mkdir project
cd project
git init
```

The directory is initialized. We have a .git directory.
```
ls -a
.  ..  .git
```

We have these in .git.
```
l -a .git/
./  ../  branches/  config  description  HEAD  hooks/  info/  objects/  refs/
```

Lets create a new file, which will be untracked.
```
touch file
git status
On branch main

No commits yet

Untracked files:
  (use "git add <file>..." to include in what will be committed)
	file

nothing added to commit but untracked files present (use "git add" to track)
```
Before staging the file, lets check a few things.

.git/index file doesn't exist
```
ll .git/index
ls: cannot access '.git/index': No such file or directory
```

.git/objects has the following entries.
```
ll .git/objects/
total 16
drwxrwxr-x 4 vagrant vagrant 4096 Oct  8 11:11 ./
drwxrwxr-x 7 vagrant vagrant 4096 Oct  8 11:22 ../
drwxrwxr-x 2 vagrant vagrant 4096 Oct  8 11:11 info/
drwxrwxr-x 2 vagrant vagrant 4096 Oct  8 11:11 pack/
```

Now lets see what happens after staging the file.
```
git add file

ll .git/index
-rw-rw-r-- 1 vagrant vagrant 104 Oct  8 11:24 .git/index

ll .git/objects/
total 20
drwxrwxr-x 5 vagrant vagrant 4096 Oct  8 11:24 ./
drwxrwxr-x 7 vagrant vagrant 4096 Oct  8 11:24 ../
drwxrwxr-x 2 vagrant vagrant 4096 Oct  8 11:24 e6/
drwxrwxr-x 2 vagrant vagrant 4096 Oct  8 11:11 info/
drwxrwxr-x 2 vagrant vagrant 4096 Oct  8 11:11 pack/

ll .git/objects/e6/
total 12
drwxrwxr-x 2 vagrant vagrant 4096 Oct  8 11:24 ./
drwxrwxr-x 5 vagrant vagrant 4096 Oct  8 11:24 ../
-r--r--r-- 1 vagrant vagrant   15 Oct  8 11:24 9de29bb2d1d6434b8b29ae775ad8c2e48c5391
```
We see that .git/index now exists and there is a new folder e6 under .git/objects.

When we stage a file
- Git saves a snapshot of the file and store is as blob in .git/objects. In this case, the content of file is saved under .git/objects/e6/. It is saved as blob. The blob is named with the 40 character SHA-1 hash of its content. 
- Git tracks the list of stages files in .git/index. 

We can see it is a zlib compressed data.
```
file  .git/objects/e6/9de29bb2d1d6434b8b29ae775ad8c2e48c5391
.git/objects/e6/9de29bb2d1d6434b8b29ae775ad8c2e48c5391: zlib compressed data
``` 

To prove that a snapshot is saved, lets delete the file in the working directory.
```
rm file
ll file
ls: cannot access 'file': No such file or directory
```

Can we still commit it?
```
git commit -m "add file"
[main (root-commit) c373546] add file
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 file
```

Yes, we can.
Lets bring it back to our working directory.

```
git checkout file
Updated 1 path from the index

ll file
-rw-rw-r-- 1 vagrant vagrant 0 Oct  8 11:32 file
```

To dive deeper into what happens when staging and committing:
- [Git Branching - Branches in a Nutshell](https://git-scm.com/book/en/v2/Git-Branching-Branches-in-a-Nutshell)
- [Git Internals - Git Objects](https://git-scm.com/book/en/v2/Git-Internals-Git-Objects)

- Ask ChatGPT:
    - "When happens during git committed"
    - "How is git commit ID computed"

## Need for staging
What is the need for staging? Why not directly commit?

- In our example, we have seen repositories with a few files only. In the real world, a repository will have hundreds of files. You may not keep track of the files you edit in your head. Hence, it would be better to select the list of files you have edited and keep them aside for commit. You get a chance to review what you stage before committing. I would think of this like a shopping cart. Add items to the cart. Review and checkout. 

- Without the chance to review before checkout, your order history will be full of cancellations. Likewise, your git history will be full of reverts, making the history very noisy and messy. 

- When you want, you have the shortcut: `git commit -am "message"`. Remember, this will automatically stage all known files, files that were previously committed but it will not stage new files.

## Remote
Git is about everyone getting a full local copy of the repository but you need some central location to collaboration. This where remote repository comes in.

In an enterprise, there will be a remote repository that is shared by all. There will be a dedicated team that owns and maintain it. Where I worked, it was maintained by a team called EngOps.

New Engineers will clone from the remote, add their code and then pushes their changes to the remote repository.

This central repository is usually create as a bare repository. A bare repository is a repository without a working area. This is because it not meant for people to edit and work out of this.

Example
```
git init --bare car.git
Initialized empty Git repository in /home/vagrant/car.git/
```
If you enter the directory, you see a structure similar to .git directory at the root itself.

```
cd car.git/
ls -1
branches
config
description
HEAD
hooks
info
objects
refs

```

>A normal repository = .git folder + your project files.
>A bare repository = only the .git folder structure (no project files to edit).


The workflow would be something like this.
- Clone the remote 
- Make changes
- Stage and commit
- Push the changes to remote

Lets look into this with an example:

Clone a remote repository.
```
git clone https://github.com/rualthan/remote_repo.git
Cloning into 'remote_repo'...
remote: Enumerating objects: 3, done.
remote: Counting objects: 100% (3/3), done.
remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 (from 0)
Receiving objects: 100% (3/3), done.
```
- This creates a directory named remote_repo on my system. 
- It initializes the .git directory inside it
- It pulls down that data from the remote repository
- It checks out a working copy of the latest version

The repository has only one file README.md as we can see below.

```
cd remote_repo
ls -la
total 16
drwxrwxr-x  3 vagrant vagrant 4096 Oct  8 13:28 .
drwxr-x--- 13 vagrant vagrant 4096 Oct  8 13:28 ..
drwxrwxr-x  8 vagrant vagrant 4096 Oct  8 13:28 .git
-rw-rw-r--  1 vagrant vagrant   13 Oct  8 13:28 README.md
```

Lets edit, stage and commit it.
```
echo "learning remote" >> README.md
git add README.md
git commit -m "update README"
[main 5c22de0] update README
1 file changed, 1 insertion(+), 1 deletion(-)
```

When we ran `git clone`, it set up a remote for us.

```
git remote -v
origin	https://github.com/rualthan/remote_repo.git (fetch)
origin	https://github.com/rualthan/remote_repo.git (push)
```

Origin is the shortname for the url on the right side. Or simply the name of our remote repository which is https://github.com/rualthan/remote_repo.git. This can be renamed or be named as you wish when setting up remote explicitly.

To rename
```
git remote set-url <new_name> <URL>
```

The next task is to push the local commits to the remote repository. This is done with the command `git push remote_name branch_name`

The remote name is origin and we want to push the main branch.

Lets push it.
```
git push -u origin main
Username for 'https://github.com':
```
We are asked to provide credentials. This is because we have not setup authentication with the remote, GitHub in this case.

To keep things simple, I will use SSH keys along with SSH url. There are other [methods](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/about-authentication-to-github).

Setup key an SSH key based authentication by following [this](https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent). 

The remote is setup with https since cloning was using using https URL.
```
git remote -v
origin	https://github.com/rualthan/remote_repo.git (fetch)
origin	https://github.com/rualthan/remote_repo.git (push)
```

Switching to SSH url.
```
git remote set-url origin git@github.com:rualthan/remote_repo.git

git remote -v
origin	git@github.com:rualthan/remote_repo.git (fetch)
origin	git@github.com:rualthan/remote_repo.git (push)

```

After this, we should be able to push

```
git push -u origin main
Enumerating objects: 5, done.
Counting objects: 100% (5/5), done.
Writing objects: 100% (3/3), 265 bytes | 265.00 KiB/s, done.
Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 (from 0)
To https://github.com/rualthan/remote_repo.git
   da3eb69..9e74328  main -> main
branch 'main' set up to track 'origin/main'.
```

While cloning, if I use SSH url, then the remote would be setup with SSH url already. 
```
git clone git@github.com:rualthan/remote_repo.git
```

To recap, when we clone a remote repository, it is auto-paired with the remote. Next, let's pair an existing local repository with a remote.

```
mkdir project
cd project/
git init
touch file
git add .
git commit -m "add file"
```

At this point, I have a clean status and no remote configured.
```
git status
On branch main
nothing to commit, working tree clean
(failed reverse-i-search)`crm': touch se^Cet/file3

git remote -v
```

Lets add a remote.
```
git remote add origin git@github.com:rualthan/remote_repo.git
```

You can get the url by
- going to the GitHub repository in your browser
- click on the green button "Code".

Remote is added.
```
git remote -v
origin	git@github.com:rualthan/remote_repo.git (fetch)
origin	git@github.com:rualthan/remote_repo.git (push)
```

But I will not be able to push to remote yet because I am yet to pull the existing data on the remote to my local. We will cover this in the next section.

### Why do we use -u with the push command?
```
git push -u origin main
```

This is to enable future push without supplying the arguments. Example:

```
cd remote_repo/
echo "learning remote is fun" >> README.md
git commit -am "update README"
[main db8640f] update README
 1 file changed, 1 insertion(+)
```

Now, lets push it without the remote and branch names.
```
git push
Enumerating objects: 5, done.
Counting objects: 100% (5/5), done.
Delta compression using up to 2 threads
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 287 bytes | 287.00 KiB/s, done.
Total 3 (delta 0), reused 0 (delta 0), pack-reused 0
To github.com:rualthan/remote_repo.git
   b1f1a05..db8640f  main -> main
```

## pull, fetch and push
Once we pair a local repository with remote by cloning or explicitly with `git remote add`, how do we sync data between the two? The answer is pull, fetch and push.

Lets bring back the previous example where we could not push after adding a remote.

```
mkdir project
cd project/
git init
touch file
git add file
git commit -m "add file"
```
Adding remote.
```
git remote add origin git@github.com:rualthan/remote_repo.git
git remote -v
origin	git@github.com:rualthan/remote_repo.git (fetch)
origin	git@github.com:rualthan/remote_repo.git (push)
```

We have a clean status.
```
git status
On branch main
nothing to commit, working tree clean
```

Push fails.
```
git push -u origin main
To github.com:rualthan/remote_repo.git
 ! [rejected]        main -> main (fetch first)
error: failed to push some refs to 'github.com:rualthan/remote_repo.git'
hint: Updates were rejected because the remote contains work that you do
hint: not have locally. This is usually caused by another repository pushing
hint: to the same ref. You may want to first integrate the remote changes
hint: (e.g., 'git pull ...') before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details.
```

The reason:
>Updates were rejected because the remote contains work that you do not have locally.

To resolve this, we need to pull that work on the remote which we do not have locally.

But git pull too failed.
```
git pull origin main
From github.com:rualthan/remote_repo
 * branch            main       -> FETCH_HEAD
hint: You have divergent branches and need to specify how to reconcile them.
hint: You can do so by running one of the following commands sometime before
hint: your next pull:
hint:
hint:   git config pull.rebase false  # merge (the default strategy)
hint:   git config pull.rebase true   # rebase
hint:   git config pull.ff only       # fast-forward only
hint:
hint: You can replace "git config" with "git config --global" to set a default
hint: preference for all repositories. You can also pass --rebase, --no-rebase,
hint: or --ff-only on the command line to override the configured default per
hint: invocation.
fatal: Need to specify how to reconcile divergent branches.
```

I had to do fetch and rebase to fix this particular situation. We will talk about rebase later.
```
git fetch origin
```
Fetch downloads the data to the local but it will merge it. Sort of like, just download and park, don't open it.

As such, we don't see any new file in our working directory.
```
ls -la
total 12
drwxrwxr-x  3 vagrant vagrant 4096 Oct 11 08:41 .
drwxr-x--- 12 vagrant vagrant 4096 Oct 11 08:41 ..
-rw-rw-r--  1 vagrant vagrant    0 Oct 11 08:41 file
drwxrwxr-x  8 vagrant vagrant 4096 Oct 11 08:43 .git
```

To get the local to the same level as remote, we need to merge or rebase. Merge didn't work, hence I rebased.
```
git rebase origin/main
Successfully rebased and updated refs/heads/main.
```

Now, we have a new file, README.md from the remote.
```
ls -la
total 16
drwxrwxr-x  3 vagrant vagrant 4096 Oct 11 08:44 .
drwxr-x--- 12 vagrant vagrant 4096 Oct 11 08:41 ..
-rw-rw-r--  1 vagrant vagrant    0 Oct 11 08:44 file
drwxrwxr-x  8 vagrant vagrant 4096 Oct 11 08:44 .git
-rw-rw-r--  1 vagrant vagrant   13 Oct 11 08:44 README.md
```
Finally, we will now be able to push from local to remote.

```
git push -u origin main
Enumerating objects: 4, done.
Counting objects: 100% (4/4), done.
Delta compression using up to 2 threads
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 271 bytes | 271.00 KiB/s, done.
Total 3 (delta 0), reused 0 (delta 0), pack-reused 0
To github.com:rualthan/remote_repo.git
   1a31381..1531fe8  main -> main
Branch 'main' set up to track remote branch 'main' from 'origin'.
```

I added a new file called file2 on the remote. Let us pull it.
```
git pull
remote: Enumerating objects: 4, done.
remote: Counting objects: 100% (4/4), done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 (from 0)
Unpacking objects: 100% (3/3), 935 bytes | 935.00 KiB/s, done.
From github.com:rualthan/remote_repo
   1531fe8..c97154c  main       -> origin/main
Updating 1531fe8..c97154c
Fast-forward
 file2 | 1 +
 1 file changed, 1 insertion(+)
 create mode 100644 file2
```

We now have file2.
```
ls -la
total 20
drwxrwxr-x  3 vagrant vagrant 4096 Oct 11 08:54 .
drwxr-x--- 12 vagrant vagrant 4096 Oct 11 08:41 ..
-rw-rw-r--  1 vagrant vagrant    0 Oct 11 08:44 file
-rw-rw-r--  1 vagrant vagrant    1 Oct 11 08:54 file2
drwxrwxr-x  8 vagrant vagrant 4096 Oct 11 08:54 .git
-rw-rw-r--  1 vagrant vagrant   13 Oct 11 08:44 README.md
```

So, what are fetch, pull and push.

- Fetch downloads data from the remote but does not do anything to the local. Your working directory is untouched.
- Pull downloads data, merges it. It is fetch + merge. The files from remote that were not on local will be available in your working directory after pull.
- Push sends your local commits to the remote. If the remote has commits from someone else that you do not have, git will reject it. You will first need to get your local on the same level as the remote and then push again.

Both pull and push involves merging at the destination. If there is a conflict of some kind, we need to resolve that. That is what I mean by bring it on the same level.

I am simplifying it here by saying "same level". Git gurus may please excuse me for now.


## Branching
To branch is to move off the path you were on. 
- We exit the main road to head into a new direction.
- Trees branch out to capture more sunlight for food(remember photosynthesis?). 

We branch out a git project to morph it into something slightly different. May be to tryout some changes without disturbing the original progression.

A git repository is a series of changes (commits) joined together and lined up chronologically, with every commit pointing to the previous. 

When we run `git init`, it creates a branch called master. 
> PS: This is often renamed to more political correct name which is main. If you create a new repository on Github, it will create a branch called main. You can set a git config to name the default branch main. 

This is what a repository with just the default branch may look it. It has three commits.

(git init)--(initial commit/Add README)--(Add file1)--(Update README)


```
git log --oneline
a453f86 (HEAD -> main) Update README
a1c3fa8 Add file1
56cb273 Add README
```

The command `git log` shows us the commits and we are in the branch main.  Is there any other branch?

```
git branch
* main
```

No. We have main branch only and we are currently on it as indicated by the asterisk sign. 

If you look up the `git log` output, the latest commit a453f86 (the top one) has "HEAD -> main". 

After adding a new commit (Add file2).
```
git log --oneline
4f4d970 (HEAD -> main) Add file2
a453f86 Update README
a1c3fa8 Add file1
56cb273 Add README
```
The HEAD and main moves with the latest commit 4f4d970. 

- What are they - HEAD, main? 
- Why are they moving?

They indicate our current location. They are pointers. Main is our only branch. So branch is a pointer pointing to the latest commit. We will get to HEAD shortly. 


Lets create a new branch.
```
git branch feature
```
There are two branches now but we are still in main.
```
git branch
  feature
* main
```

Checking `git log`.
```
git log --oneline
4f4d970 (HEAD -> main, feature) Add file2
a453f86 Update README
a1c3fa8 Add file1
56cb273 Add README
```

There are three pointers HEAD, main and feature attached to the latest commit f4d970. 
Lets note the order "(HEAD -> main, feature)".

Switching to feature branch.
```
git checkout feature
Switched to branch 'feature'

git branch
* feature
  main

git log --oneline
4f4d970 (HEAD -> feature, main) Add file2
a453f86 Update README
a1c3fa8 Add file1
56cb273 Add README
```

We are in feature branch indicated by * sign, `git log` shows the same information except that the order is different "(HEAD -> feature, main)".

So what does this tell us? HEAD points to the current branch while branch points to the latest commit, our current location.

Right now, both the branches main and feature points to the same commit ID 4f4d970. This is because we haven't made any commit after creating a new branch. We decided to go in different direction but we haven't taken the next step. We are still at the intersection.

Before taking the next step, let me show you the working directories of both the branches.

main
```
git branch
  feature
* main

ls
file1  file2  README.md
```

feature
```
git checkout feature
Switched to branch 'feature'

ls
file1  file2  README.md
```

They have the same files. This should be no surprise. So far, main and feature points to the main commit. Right now, they are identical.

If anyone tells you a new branch gets a copy of the source branch. This is wrong. This may be true for other VCS where branch involves a copy of data to a new directory.

This is not so with Git. This is why they they say branching is fast, easy and cheap with Git. 

Even if you check the size of the project directory before and after creating a new branch, you will see a minimal increment only.

```
vagrant@vagrant:~/project$ du -sh .
280K	.
vagrant@vagrant:~/project$ git branch new
vagrant@vagrant:~/project$ du -sh .
288K	.
```

Branch creation will only result in the addition of some metadata.


Now lets take the next step and start adding changes to feature branch.

```
git branch
* feature
  main

touch feature_file
git add .
git commit -m "Add feature_file"
```

Checking the log.
```
git log --oneline
e80c1e2 (HEAD -> feature) Add feature_file
4f4d970 (main) Add file2
a453f86 Update README
a1c3fa8 Add file1
56cb273 Add README
```

- feature moves to the commit 80c1e2
- HEAD points to feature because it is the current branch
- main stays at 4f4d970 

main stood still while feature moves ahead. Lets add file3 to main.
```
git checkout main
Switched to branch 'main'

touch file3
git add .
git commit -m "Add file3"
```
Where is main?
```
git log --oneline
6274383 (HEAD -> main) Add file3
4f4d970 Add file2
a453f86 Update README
a1c3fa8 Add file1
56cb273 Add README
```

main moves to 6274383. What happened to the commit e80c1e2 we made in feature branch? Why don't we see it here. We shouldn't. That is now on a different branch or line. They- main, feature are now on their own path. The commonality ends at 4f4d970. 

Will they meet again? It us up to us. We will see that in merging and rebase. 

### The source of information
We use the command `git branch` and `git log` to show the current branch and in which commit each branch is. Commands retrieve information and display it. They do not store information.
Where is the information stored? 

Look at the content of the .git/HEAD as we switch branches.

```
git branch
* feature
  main
cat .git/HEAD
ref: refs/heads/feature

git switch main
Switched to branch 'main'
cat .git/HEAD
ref: refs/heads/main
```

Where are the branch details stored?
```
ll  .git/refs/heads/
total 16
drwxrwxr-x 2 vagrant vagrant 4096 Oct 11 17:24 ./
drwxrwxr-x 4 vagrant vagrant 4096 Oct 11 15:53 ../
-rw-rw-r-- 1 vagrant vagrant   41 Oct 11 17:06 feature
-rw-rw-r-- 1 vagrant vagrant   41 Oct 11 17:24 main
```

The main branch points to the commit 6274383.
```
git log --oneline
6274383 (HEAD -> main) Add file3
```

This information is stored in:
```
cat .git/refs/heads/main
62743839af049203c0a1491318be99e7dd1c9379
```
**627438**39af049203c0a1491318be99e7dd1c9379

Likewise for feature.
```
git switch feature

git log --oneline
e80c1e2 (HEAD -> feature) Add feature_file
...

cat .git/refs/heads/feature
e80c1e232a9fcd1711fa9e6ac863b440a1e90c7a
```
**e80c1e2**32a9fcd1711fa9e6ac863b440a1e90c7a


### Why checkout to switch a branch 
That is a good question. The checkout command is inherited from older VCS softwares. In those systems, checking out meant:
>“Give me the files from a specific revision or branch so I can work on them.”

With Git, you can checkout a branch, a commit-hash and a file. This is confusing. A new command `switch` was introduced for switching branch.

Switch branch
```
git switch branch_name
```

Create branch and switch
```
git switch -c branch_name
```

The checkout equivalents.
```
git checkout branch_name
git checkout -b branch_name
```

### Why branch?
Lets get back to why branch? Why would we want to do it?

We will use a car manufacturing analogy. For efficiency and optimization, the automobile industry creates different cars using the same platform. Usually, similar chassis and engine but different body style. An SUV and a Sedan version off the same platform is all too common right now in India. 

It might look like this.
- Start with main branch which is the platform
- Add Chassis
- Add Engine
    - SUV branch
        - Add SUV body
        - Add something SUV specific
    - Sedan branch
        - Add Sedan body
        - Add something Sedan specific
- Add Chassis_v2
- Add Engine_v2

The commonality ends after engine. I don't want to add the body in my main because the body is specific. The main is my platform, my blueprint. Anything done in main should be generic.

In main, I will improve the engine and chassis for my platformv2. In future, I will branch out to my newer versions of SUV and Sedan.

For a software release, it would be something like:
- Add feature1
- Add feature2
    - release v1
- Add feature3
- Update feature1
- Update feature2
    - release v2

Once I have sufficient feature for my v1 release, I will cut a new branch for v1. Builds will be created off this branch and tested. Any changes specific to v1 will be done in this branch only. Meanwhile, the main branch will go on with more features and improvements. At some point in future, a v2 release will branch off. 

## Merging
We introduced branching as a way to spin off and go in direct direction. This is one use case. You may want to take whatever you have built  till a point and give it out as version x.

There are other reasons to branch. You may want to build a new feature in isolation to avoid messing up the main branch. Once the feature is ready, you want to bring it back to main. How you do it is merging.

Back to our car analogy. 

We are building our platform.

(init)--(add chassis)--(add engine)

I would like to add ADAS. I don't want to hold up the main line, I don't want to mess it up. Therefore, I will create a new branch adas and work on it. Once it's ready, I will bring it back to the main branch.


```
mkdir car
cd car/
git init
touch chassis
git add chassis
git commit -m "Add chassis"
touch engine
git add engine
git commit -m "Add engine"
git branch adas
```

Lets work on our ADAS.
```
git switch adas
touch adas
git add .
git commit -m "Add adas"
git log --oneline
0a638aa (HEAD -> adas) Add adas
6740844 (main) Add engine
cfad10c Add chassis
```

Meanwhile, we have updated the engine in the main line. The main line had moved ahead since created the adas branch after adding engine.
```
git log --oneline
368d9bc (HEAD -> main) Update engine
6740844 Add engine
cfad10c Add chassis
```

Lets bring adas to the main line, our platform.
```
#Check we are in main
git branch
  adas
* main

#Check history and working directory
git log --oneline
ee490fa (HEAD -> main) Update engine
57f3346 Add engine
6595637 Add chassis

ls
chassis  engine

#Merge it
git merge adas
Merge made by the 'ort' strategy.
 adas | 0
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 adas
```

The merge command opens up a text editor for you to enter the merge message. It comes with this default text.

```
Merge branch 'adas'
# Please enter a commit message to explain why this merge is necessary,
# especially if it merges an updated upstream into a topic branch.
#
# Lines starting with '#' will be ignored, and an empty message aborts
# the commit.
```
Save the file to complete the merge.  

After merge, check log and working directory.
```
git log --oneline
f7e7e73 (HEAD -> main) Merge branch 'adas'
ee490fa Update engine
0a638aa (adas) Add adas
57f3346 Add engine
6595637 Add chassis

ls
adas  chassis  engine
```

We see the merge commit at the top and we have adas now in our working directory. Adas is now on the main line. We are ready to build our next gen SUVs and Sedans.

What happened to the adas branch?
It remains intact and we can delete it.
```
git branch
  adas
* main

git branch -d adas
Deleted branch adas (was 9c2f126).

git branch
* main
```

### We have a problem - merge conflict
This is our main branch. Notice the engine has been updated.
```
git log --oneline
fe7486f (HEAD -> main) Update engine
0b2d1fd (adas) Add engine
1206eba Add chassis
```

In the adas branch, adas feature was added and the engine was also updated, for some reason. This is going to create a problem.
```
git log --oneline
fb12287 (HEAD -> adas) Update engine
abeda9e Add adas
0b2d1fd Add engine
1206eba Add chassis
```

Try to merge. 

```
git switch main
git merge adas
Auto-merging engine
CONFLICT (content): Merge conflict in engine
Automatic merge failed; fix conflicts and then commit the result.
```

As expected, we have a conflict. Since we branch off adas from main, the engine (in this case, the file) has been updated in two places. When we try to merge adas to main branch, we have a conflict due to this. 

We have two versions of engine update. The file engine in the working directory of main will now look like this.

```
cat engine
<<<<<<< HEAD
Update
=======
Update for ADAS
>>>>>>> adas
```

- "Update" was made in main branch.
- "Update for ADAS" was added in adas branch.

We have to decide which one to keep. We will take "Update". Edit the file to look like this.

```
cat engine
Update
```

As indicated by the merge conflict message, we have to commit this.
```
vi engine
git add .
git commit -m "fix merge conflict"
[main 7955c31] fix merge conflict
```

The main branch has adas. The engine update that conflicted was resolved and added as a new commit.

```
git log --oneline
7955c31 (HEAD -> main) fix merge conflict
fb12287 (adas) Update engine
abeda9e Add adas
fe7486f Update engine
0b2d1fd Add engine
1206eba Add chassis
```
Conflict occurs when the branches you are trying to merge has files with dissimilar content.


## Rebase
When it comes to pizza, I prefer thin crust base. I ordered a thin crust based pizza but they gave me a thick crust based on. On my complain and polite request, they changed the base to a thin one. They have re-based my pizza.

Lets focus on "base". Look at this timeline which must be very familiar by now.
```
git log --oneline
6cd1560 (HEAD -> main, suv, sedan, adas) Add engine
988f9e8 Add chassis
```
There are 4 pointers or branches point to 6cd1560. These branches are based on this commit. Meanwhile, the main branch had moved ahead. It now has engine update and adas.

```
git log --oneline
ddea622 (HEAD -> main) Merge branch 'adas'
0d55de4 (adas) Add adas
212d3bf Update engine
6cd1560 (suv) Add engine
988f9e8 Add chassis
```

What if we could change the base of our sedan branch to the current state out platform (main), ddea622? We can actually do that and that is called rebase.

### But why?
Our management has decided to go all in and focus on the niche sedan market. All the big players have given up sedan. This might work for us as a small player. With this decision, we don't have to maintain a platform for two cars. We can put all our effort on the main line. So, we are going to rebase our sedan line with all latest updates in the main line and still retain the changes we have made in the sedan line.

```
git switch sedan

git rebase main
Successfully rebased and updated refs/heads/sedan.
```

Before rebase
```
git log --oneline
3602934 (HEAD -> sedan) Add sedan_body
6cd1560 (suv) Add engine
988f9e8 Add chassis
```

After rebase, sedan_body is added after engine update and adas.
```
git log --oneline
bed8ca2 (HEAD -> sedan) Add sedan_body
ddea622 (main) Merge branch 'adas'
0d55de4 (adas) Add adas
212d3bf Update engine
6cd1560 (suv) Add engine
988f9e8 Add chassis
```
6cd1560 (suv) Add engine
Our Sedan line is now based on ddea622, instead of before. Rebasing moves the pointer to the latest commit in the based branch (main) and then it appends its own commits.

If we merge sedan to main, it would look like this.
```
git switch main

git merge sedan
Updating ddea622..bed8ca2
Fast-forward
 sedan_body | 0
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 sedan_body

git log --oneline
bed8ca2 (HEAD -> main, sedan) Add sedan_body
ddea622 Merge branch 'adas'
0d55de4 (adas) Add adas
212d3bf Update engine
6cd1560 (suv) Add engine
988f9e8 Add chassis
```

main and sedan are at the main location whereas adas and suv did not move. Without knowing the history, it looks like sedan branch had just be created and based off the current state of main. Aside from our business reason,  this gives a cleaner and linear history. It is preferred in some situation.

## cherry-pick
An updated engine was added to our platform (main) after we branch off SUV and Sedan. It will be available in the new versions built off the updated platform along with other features that we may add such as ADAS. But competing is heating up. 

Can we bring the updated engine to our existing line of Sedan now? Yes, we can.

We have chassis and engine in our platform. Then we create branches for SUV, Sedan and ADAS.
```
git log --oneline
9500393 (HEAD -> main, suv) Add engine
c731f80 Add chassis
```

We added updated engine to the platform and ADAS was merged to main from adas branch. 

```
git log --oneline
061e52c (HEAD -> main) Merge branch 'adas'
d7d141e Update engine
a765b0d (adas) Add adas
9500393 (suv) Add engine
c731f80 Add chassis
```

In Sedan line, based off the chassis and engine from our platform, we added a sedan body.

```
git switch sedan
Switched to branch 'sedan'

git log --oneline
9cb902a (HEAD -> sedan) Add sedan_body
9500393 (suv) Add engine
c731f80 Add chassis
```

Lets bring the updated engine to the current line of Sedan.
```
# Always check current branch
git branch
  adas
  main
* sedan
  suv

git merge main
Merge made by the 'ort' strategy.
 adas   | 0
 engine | 1 +
 2 files changed, 1 insertion(+)
 create mode 100644 adas
```

We have got the updated engine (d7d141e) in our Sedan line. 

```
git log --oneline
eaaddfe (HEAD -> sedan) Merge branch 'main' into sedan
061e52c (main) Merge branch 'adas'
d7d141e Update engine
9cb902a Add sedan_body
a765b0d (adas) Add adas
9500393 (suv) Add engine
c731f80 Add chassis

ls
adas  chassis  engine  sedan_body
```

We have got something else too. The ADAS feature. This is planned for our future Sedan line. Merging main to sedan brings to sedan all the changes in main made since the sedan branched off. How do we selectively bring just the change we want- updated engine to Sedan line?

The answer is cherry-picking. Lets do this again. The main line got an updated engine and ADAS has been merged to main.
```
git log --oneline
e88eca3 (HEAD -> main) Merge branch 'adas'
3d4840b Update engine
a416353 (adas) Add adas
b4a4347 (suv) Add engine
fc68df1 Add chassis
```

We added body to our SUV line.
```
git log --oneline
46821ee (HEAD -> sedan) Add sedan_body
b4a4347 (suv) Add engine
fc68df1 Add chassis
```

The change we want is updated engine represented by commit hash 3d4840b. Lets bring it to sedan.
```
git cherry-pick 3d4840b
[sedan b14d0a3] Update engine
 Date: Sun Oct 12 08:05:04 2025 +0000
 1 file changed, 1 insertion(+)
```

```
git log --oneline
b14d0a3 (HEAD -> sedan) Update engine
46821ee Add sedan_body
b4a4347 (suv) Add engine
fc68df1 Add chassis
```

We have refreshed our existing Sedan line with an updated engine.

In the real world, cherry-picking is often used to backport bugfixes.  

Where I used to work, the product had lots of bugs. The fix will be first available on the main branch and then cherry-picked to the release branch where it was reported.

I used to ask the Engineers what cherry-picking means in the git sense. No one could give an answer I could understand. Now that I have learned it, I don't blame them. There's no way I would understand git cherry-picking without knowing git branching and merging. 

## Stashing
You are implementing a feature. You have staged the changes but you are not ready to commit yet. There's a hot customer escalation due to a bug. You have been asked to fix it. You tried to switch branch but git won't allow it as you have uncommitted changes. 

What can you do? Open a new terminal tab. This will work as long you can track it in your head. 

Is there a way to safely park your current work and continue it later? 

Yes. Stashing.

Here's our situation. 
```
git status
On branch master
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
	modified:   file1

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   file2

Untracked files:
  (use "git add <file>..." to include in what will be committed)
	untracked.txt
```
We have three situations:
- Untracked: We have a new file untracked.txt that has never been committed before.
- Staged: file1 is staged.
- Not Staged: file2 is updated since the last commit but not staged. 

Let save them temporarily the git way.
```
git stash
Saved working directory and index state WIP on master: 1d40cc2 Update file
```

SITREP
```
git status
On branch master
Untracked files:
  (use "git add <file>..." to include in what will be committed)
	untracked.txt

nothing added to commit but untracked files present (use "git add" to track)
```
The files file1 and file2 disappeared from our radar but not the untracked file. 

We can now switch branch. Git doesn't care about untracked files. But if you want to include untracked files, use `git stash -u`.

Once we are done with the bugfix, to continue working on our changes, lets bring them  back to the working directory.
```
git stash pop
``` 

SITREP
```
git status
On branch master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   file1
	modified:   file2

Untracked files:
  (use "git add <file>..." to include in what will be committed)
	untracked.txt

no changes added to commit (use "git add" and/or "git commit -a")
```

They have are back but this time, both are in the unstaged state.

Lets summarize and list other commands
- Add modified and staged changes to stash: `git stash`
- Include untracked files to stash:`git stash -u`
- Add a message while stashing:`git stash "message"`
- Bring the stashed changes to working directory and delete it from stash: `git pop`
- Bring the stashed changes to working directory and don't delete it from stash: `git apply`
- List the changes in stash:`git stash list`
- Delete everything in stash:`git stash clear`
- Operate on a specific change in stash:
  - `git stash drop stash@{0}`
  - `git stash apply stash@{1}`

## git diff
Version control is recording changes so we can compare them later. 

Lets compare working directory vs staging area

In a new repository, touch a new file and stage it.
```
mkdir car/
cd car/
git init
touch file1
git add .
```

Compare working directory and staging.
```
git diff
```
No difference. Lets update the file in working directory.
```
echo "fixing ..." >> file1
```

Compare again.
```
git diff
diff --git a/file1 b/file1
index e69de29..ca9065b 100644
--- a/file1
+++ b/file1
@@ -0,0 +1 @@
+fixing ...
```

Lets dissect this in detail.

- --- a/file1 represents old file
- --- b/file1 represents new file

Which is old and which is new?
`git diff` compares working directory with staging. But who has the old or new. You can edit file that is already staged but you can edit the file in working directory. So the old one will be staging.

- @@ -0,0 +1 @@
  - -0,0 Lines starting from 0 up to 0 lines have been extracted from the old.
  - +1 Line number 1 is extracted from the new.


Therefore, `+fixing ...` from extracted line indicates
- it is from new indicated by + sign
- This is line number in the new file because we saw line number 1 is extracted from the new.

Lets try another one.
```
git diff
diff --git a/file b/file
index f384549..1209ac5 100644
--- a/file
+++ b/file
@@ -1,4 +1,4 @@
-one
+first
 two
 three
 four
```
From each version, four lines are extracted, that is starting from line #1, up to four lines from there. 

```
-one
+first
```
This represents two versions of the first line.
-one from the old and +first from the new.
Can we assemble the two versions of the file?

Old (staging)
``
one
two
three
four
``

New (working directory)
```
first
two
three
four
```


Another situation.
```
git diff
diff --git a/file b/file
index f384549..b910988 100644
--- a/file
+++ b/file
@@ -1,4 +1,3 @@
-one
 two
-three
+third
four
 ```

Old file (-1,4)
4 lines start from line 1.
```
one
two
three
four
```

New file(+1,3)
3 lines start from line 1.
```
two
third
four
```

Lets verify.

Staged:
```
git show :file
two
three
four
```

Working directory:
```
cat file
one
two
three
four
```

So, in the lines extracted:
- lines from the old have - sign
- lines from the new have + sign
- lines present in both have no sign


Other situations:

1. Compare staging area vs last commit
    ```
    git diff --cached 
    OR
    git diff --staged
    ```

2. Compare working directory vs last commit
    ```
    git diff HEAD
    ```

3. Between two commits
    ```
    git diff <commit1> <commit2>
    ```

4. Between branches
    ```
    git diff main feature
    ```

5. Between a file in two commits
    ```
    git diff commit1 commit2 -- path/to/file
    ```

The `-- path/to/file` can be applied to other comparisons. This is useful when multiple files had been updated but you want to limit the comparison to a file.

## Undo's
What good would a VCS tool be if we can only track changes and cannot undo our mistakes.

1. You lost a file in the working directory, or you simply want to revert to the latest commit.

      ```git checkout file_name```

2. Unstage a file that is currently staged/
    ```
    git restore --staged file_name
    ```

3. Undo the latest commit
    ```
    git revert head
    ```
    Will undo the latest commit and record it as a new commit. The history mains intact.

4. Undo the last commit but keep files staged
    ```
    git reset --soft HEAD~1
    ```
    Use HEAD~2 for last two and so on. It will remove the commits but keep files in staging. Check log before and after this command and note position of HEAD. This is the default mode.
5. Undo the last commit and unstage files (keep work in working dir)
    ```
    git reset --mixed HEAD~1
    ```
    It will remove the last commit but the file remains in working area.
6. Completely discard last commit and all changes
    ```
    git reset --hard HEAD~1
    ```
    Removes the last commit, deletes their respective copies in working directory. Clears everything in staging and their respective copies in working directory.
7. Undo upto a specific commit
    ```
    git reset <commit-hash>
    ```
8. To recovery files after a reset
    ```
    git reflog
    ```
    Gives you a local history of the HEAD including those not available in the branch history (git log). From here, find the commit hash just before the reset from which you want to recover.
    ```
    git reset --hard <commit-hash>
    ```
    This will restore the commit and also brings back the file to working directory. Check `ls` and `git ls-tree HEAD` before and after.
     

## git init, again
What would happen if you run git init the second time in a directory that is already initialized?

```
git init
Reinitialized existing Git repository in /path/to/your/project/.git/
```

Nothing happens. My commits are intact. The history remains the same.

## Exploring .git directory.
Running `git init` creates the .git directory structure. We have covered the important locations. Lets review it

- .git/COMMIT_EDITMSG has the message from the latest commit
- .git/HEAD stores the current branch HEAD points to
- .git/index is the list of staged changes. This is why staging area is also called index.
- .git/objects/ has the files we staged and commit as blobs
- .git/refs/heads/ stores the branches info


## Rename and delete
What is the git away to delete, rename or move a file?

We have three files in our working directory.
```
ls
file1	file2	file3
```
The three files are committed to the repository.
```
git ls-tree HEAD
100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391	file1
100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391	file2
100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391	file3
```

Adding and stage README.
```
touch README.md
git add .
```

Delete it from working directory.
```
rm README.md
```

It remains in our staging area, as it should. Git also records the deletion of the file in the working directory as a change. There are now two items in `git status` output.

- The change that is staged (the addition of README.md)
- The change that is not staged (the deletion of README.md)

```
git status
On branch master
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
	new file:   README.md

Changes not staged for commit:
  (use "git add/rm <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	deleted:    README.md
```

First, lets commit the earlier staging.
```
git commit -m "Add README"
```

README is in the repository.
```
git ls-tree HEAD
100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391	README.md
100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391	file1
100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391	file2
100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391	file3
```

Lets stage and commit the new change which is the deletion of README.md.
```
git status
On branch master
Changes not staged for commit:
  (use "git add/rm <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	deleted:    README.md

no changes added to commit (use "git add" and/or "git commit -a")

git add .

git commit -m "rm README"
[master 6384309] rm README
 1 file changed, 0 insertions(+), 0 deletions(-)
 delete mode 100644 README.md
```

List the repository content, README is gone.
```
git ls-tree HEAD
100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391	file1
100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391	file2
100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391	file3
```

So the idea is to treat deletion just like the other events such creation and edition files. Then, stage and commit it.

There's a shortcut.
- `git rm file` will delete the file in the working directory and staging. You still need to commit it just like any other change.
- `git mv file`: Similarly, for renaming or moving the file to dirent directory.   

## Git alias
We can create shorthand version of git commands. To create a shorthand for `git status`:
```
git config --global alias.st status
```
After this, `git st` will run `git status`. 

To set aliases for a specific repository, navigate to that repository and run the commands without the `--global` flag.

## Tagging
Tagging is a way to label or tag a commit, usually used to mark a release point for example: v1.0.0 .

- `git tag` to list the tags, the order doesn't matter
- `git tag v1.0` to tag the latest commit (Lightweight tag)
- `git tag -a v1.0 -m "your message"` to tag the latest commit (Annotated tag)
- `git tag -a v1.0 <commit ID>` to tag a previous commit
- `git show <tag>` to display the details of the <tag> 
- `git push origin v1.5` push a specific tag, tags are not pushed by default
- `git push origin --tags` push all tags

The coverage on this topic on the [Official Book](https://git-scm.com/book/en/v2/Git-Basics-Tagging) is good as usual. You should just go and read that chapter. 

## Other use
Git or any other VCS is primary used for source code management. The second common use might be documentation. The documentation team in my previous company uses git. 

This blog is hosted on GitHub. I use git workflow to maintain it. 

## Git for backup people
As I bring myself up to speed on the basic Git workflows, I couldn’t just move on without some understanding of how things work behind the scenes.  Having worked on backup for 7 years, and as I learn more about Git internals, I see that it’s a lot like backup.

- zlib compressed blob
- blob level deduplication (global dedupe within a repository) 
- Remove unreferenced blobs during git gc

When I get these ideas, I usually push them to WhatsApp groups.

But why bore a few when you can bore the world?

So, introducing Git to backup people:

### Working Directory
The data on servers and databases, etc., which users create and modify.

### Staging (git add)
Creating a backup job, selecting the data you want to backup.

### Commit (git commit) 
Run the backup

## The HEAD and tape recorder

The HEAD reminds me of the head in tape recorders and VCR/VHS players. It reads from the tape and writes to the tape. As we play the tape, the head is sort of the positional indicator. 

Some tape recorder had dual cassette deck. It could record from one to the other. We would make a tape with a collection of chosen songs. Quite often, a T-Series cassette of some Hindi film was cheaper than a blank cassette. It was our alternate or preferred source of blank tape.

It could also record your voice. That is how oldies made home audio tapes.

To record, we hit the play and record buttons together. To create a non-stop tape or undo a part of the recording, we would rewind which would re-position the head. That's how undo,revert. Fun times!

## Contributing to a project
To contribution to an Open Source project which is hosted in a GitHub, the high level steps would be:

1. Fork the project on GitHub
2. Clone your forked repository
3. Create a branch and add code
4. Commit the changes and push it
5. Create a pull request from GitHub
6. The project maintainers review and merges it if approved.
















