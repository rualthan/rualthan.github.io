---
layout: post
title: Ansible
---

Ansible is an open-source IT automation software. It was written by Michael DeHaan in 2012. The company Ansible, Inc for commercial support was founded in 2013 and acquired by Red Hat in 2015.

Michael was the maintainer of Cobbler, the provision service used by Red Hat Satellite server. 

The term [ansible](https://en.wikipedia.org/wiki/Ansible) is a fictional faster than light communication technology, first used by Ursula K. Le Guin in her 1966 novel Rocannon's World.
But Dehaan [said](https://groups.google.com/g/ansible-project/c/djZklLE2wIE/m/XCEOIq0RbN4J) he named the software after the ansible in the novel Ender's Game.

# Table of Contents
- [IaC](#iac)
- [Key points](#key-points)
- [Ansible in action](#ansible-in-action)
- [Inventory](#inventory)
- [Adhoc command](#adhoc-command)
- [Playbook](#playbook)
- [Variable in playbook](variable-in-playbook)
- [Loop](#loop-in-playbook)
- [Modules](#modules)
- [Plugins](#plugins)  
- [Facts](#facts)
- [Handlers](#handlers)
- [Altering behavior](altering-behavior)
- [List hosts](#list-hosts)
- [Validators](#validators)
- [Check mode](#check-mode)
- [Secrets](#secrets)


## IaC
Infrastructure as Code (IaC) is the automation of infrastructure management and provisioning. This includes codifying the creation of servers, the installation of softwares in the servers and how the services in it should work.

When you have it as a code, you can version control it and reuse it.

It can ve a push or pull mode. A push model is where the IaC control node pushes the instructions to the managed nodes. In a pull mode, the servers will fetch the their instructions from the control node. 

IaC can be declarative or imperative. A declarative approach focuses on the outcome, the desired state. An imperative approach defines the step by step procedures.

The latest trending IaC tools appear to be:
- Ansible
- Terraform/OpenTofu
- Pulumi 
- AWS CloudFormation

There doesn't seem to be a reliable index or ranking of IaC tools like the ones for programming languages. So, take this with a pinch of salt.

If you are starting from zero in IaC, I think you are can't go wrong with Ansible and Terraform. 

For a list of other IaC tools and the differences between, have a look at the table on this [Wikipedia page](https://en.wikipedia.org/wiki/Infrastructure_as_code). 


## Ansible - Key points
- Written by Michael DeHaan in 2012 
- Ansible, Inc was bought by Red Hat in 2015
- Ansible is mostly Push but supports pull though it's rare
- It is both declarative and imperative
- Install it with the OS package manager or using PIP
- Control node - The host where ansible is installed
- You can run Ansible in containers known as Execution Environments
- Managed node - The target host managed by Ansible
- Ansible and Python are required on the control node
- Python is required on the managed
- The managed nodes should be reachable by SSH while other methods are also supported.
- The inventory is a list of managed nodes
- The default inventory is /etc/ansible/hosts
- The inventory file supports INI and YAML
- Playbook is the file containing the set of instructions to be executed on the managed node. It is written in YAML.
- Modules is the code that are sent to the managed node for execution.
- Modules are predominantly written in Python but can be developed in any language.

## Ansible in action
We will install unzip on a remote host using Ansible.

Inventory:
```
cat inventory
192.168.56.45
```

### Adhoc command
Command:
```
ansible all  -i inventory  -m package -a "name=unzip state=present" --become
```

Output:
```
192.168.56.45 | CHANGED => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python3"
    },
    "changed": true,
    "msg": "",
    "rc": 0,
    "results": [
        "Installed: unzip-6.0-69.el10.aarch64"
    ]
}
```

### Playbook
Playbook:
```
cat unzip.yaml
- name: Install unzip
  hosts: all
  become: true
  tasks:
    - package:
        name: unzip
        state: present
```
Command to run playbook:
```
ansible-playbook -i inventory  unzip.yaml
```

Output:
```
PLAY [Install unzip] ****************************************************************************************************************************************

TASK [Gathering Facts] **************************************************************************************************************************************
ok: [192.168.56.45]

TASK [package] **********************************************************************************************************************************************
changed: [192.168.56.45]

PLAY RECAP **************************************************************************************************************************************************
192.168.56.45              : ok=2    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0
```

if you repeatedly run the command or playbook, Ansible knows that the program is already installed. It will not make any change. You will see `"changed": false` and `changed=0` in the respective methods.

## Inventory
Inventory is a list of hosts managed by Ansible. It can be a simple list of hosts or divided into groups. There can be host level or group level variables. It can be written in INI or YAML. 

The default inventory is /etc/ansible/hosts. To use other inventory it has to be provided with -i flag on the command line.

A simple inventory with just a list of hosts:
```
#INI Format
host1
host2.example.com
host3.example.com
```

```
#YAML
host1
host2.example.com
host3.example.com
```

It can be an IP address, FQDN or shortname as long as the control node can resolve it.

An inventory file with group and without group:
```
#INI
host1

[prod]
host2.example.com
host3.example.com
```

```
#YAML
host1

prod:
  - hosts:
      host2.example.com:
      host2.example.com:
```
There are two default groups: all and ungrouped. The all group contains every host in the inventory. The ungrouped group contains all hosts that do not belong to any other group.


Host alias and host level variables can be added as:
```
node1 ansible_host=192.168.56.45 ansible_connection=ssh ansible_user=vagrant
```

where node is an alias followed variables with the information to be used to connect to the node. 

The YAML version is:
```
ungrouped:
  hosts:
    node1:
      ansible_host: 192.168.56.45
      ansible_connection: ssh
      ansible_user: vagrant
```

To validate the inventory, use ansible --list-hosts command.
```
ansible --list-hosts  all -i  inventory.yaml
  hosts (1):
    node1
```

Other points:
- We can have variables at group level. 
- There can be  a group of groups using :children suffix for INI  or children: mapping for YAML.
- You can provide multiple inventories to the ansible or ansible-playbook commands.
  ```
  ... -i inventory1 -i inventory2
  ```

- Inventory files can be placed in a directory. We can use the directory itself as the inventory input in our commands.
- In the real world, the list of nodes will often change. Ansible supports dynamic inventory for this situation. 

I recommend reading the /etc/ansible/hosts file comment section and the [official guide](https://docs.ansible.com/ansible/latest/inventory_guide/index.html) to understand the complete set of options available.

## Adhoc command
Adhoc commands are ansible one liners which are useful for some quick tasks. For longer and more complex tasks which we are likely to reuse, there's playbook.

This is an adhoc command to ping all hosts in the inventory.

```
ansible all -m ping -i inventory
```

To execute a shell command on a remote host:
```
ansible 192.168.56.45 -i inventory  -m shell -a "echo $SHELL"
```

To install unzip package on all hosts in the inventory:
```
ansible all  -i inventory  -m package -a "name=unzip state=present" --become
```

The syntax is:
```
ansible [pattern] -m [module] -a "[module options]"
```
It uses the default inventory if a different one is not provided with `-i inventory_name`.  

Pattern is how you select which nodes to target. It can be a host, the all group, your defined groups, wildcards or regex. The `--become` is a plugin to invoke sudo. 

Reference [the official doc](https://docs.ansible.com/ansible/latest/inventory_guide/intro_patterns.html) for the entire range of supported patterns.

`-m` to say which module to use and `-a` to provide the module options. The ping module can run without any options provided. 

The shell and package modules need options.
How does one know the options for a module?
We will get back to this.

## Playbook
A playbook is written in YAML. It is where you write what you want to be done on managed nodes and which nodes you want to target. 

At a minimum, a playbook has:

1. The managed nodes to target, using a pattern.

2. At least one task to execute.

This is a bare minimum playbook.
```
- hosts: all
  tasks:
    - shell: date
```

To execute the playbook:
```
ansible-playbook -i <inventory> <playbook>
```


There was an error and before I corrected it, the ansible-playbook error message said - "A playbook must be a _list_ of plays". According to the official doc, "A playbook consists of one or more ‘plays’ in an ordered _list_".

Lets focus on the word _list_. 

In the sample playbook, the top element is a list (sequence in YAML). The list has only one element whose content is two pairs of key/values (mapping in YAML). The first pair is `hosts: all` which we use to select the nodes to target. The key for the second pair is `tasks` whose value will be a list again.

Thus, the format of a playbook is:
```
- hosts: PATTERN
  tasks:
    - module1: module_name
    - module2: module_name
```

Usually, the modules have options which will become a child item of the module.
```
- hosts: PATTERN
  tasks:
    - module1: module_name
        option1: value  
    - module2: module_name
        option1: value
        option2: value  
```
This is a playbook with two tasks.
```
- hosts: all
  become: true
  tasks:
    - package:
        name: unzip
        state: present
    - file:
        path: /tmp/ansible
        state: touch
```

Lets take our bare bones playbook and run it through a syntax check.

date.yaml:
```
- hosts: all
  tasks:
    - shell: date
```

  ```
  ansible-playbook --syntax-check date.yaml
  ```
No error.

Next, we will use the ansible linter ansible-lint. 

Running `ansible-lint  date.yaml` flags 7 violations. The output is rather large. I will just list out the violations.

1. name[play]: All plays should be named.
date.yaml:1

2. command-instead-of-shell: Use shell only when shell functionality is required.
date.yaml:3 Task/Handler: shell date

3. fqcn[action-core]: Use FQCN for builtin module actions (shell).
date.yaml:3:7 Use `ansible.builtin.shell` or `ansible.legacy.shell` instead.

4. name[missing]: All tasks should be named.
date.yaml:3 Task/Handler: shell date

5. no-changed-when: Commands should not change things if nothing needs doing.
date.yaml:3 Task/Handler: shell date

6. yaml[trailing-spaces]: Trailing spaces
date.yaml:3

7. yaml[trailing-spaces]: Trailing spaces
date.yaml:4

### Violation 1 and 4
We should name the play and each tasks. Lets fix that. The relevant line numbers are 1 and 3, as indicated in the violation message. 

```
- name: Display the date on the remote host
  hosts: all
  tasks:
    - name: Run the date command
      shell: date
```
This resolves two violations. The rookie mistake here is to create a new list item as in:
```
   - name: Run the date command
   - shell: date
```
Note that we are not adding a new task. It is a part of the same task. It is a new key/value pair in the first task.

### Violation 2
There's a dedicated module to run commands. By running `date` with shell, we are not using any shell functionality. Lets use the command module.
```
- name: Display the date on the remote host
  hosts: all
  tasks:
    - name: Run the date command
      command: date
```
The previous violation was replaced by another which I will ignore. Our example playbook isn't a great example of how you should use ansible.

### Violation 3
Quoting the [official doc](https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_intro.html#playbook-execution)
>For Ansible 2.10 and later, you should use the fully-qualified collection name (FQCN) in your playbooks. Using the FQCN ensures that you have selected the correct module, because multiple collections can contain modules with the same name.

The FQCN for command module is `ansible.builtin.command.` 

Collection is, as per the [official doc](https://docs.ansible.com/ansible/latest/collections_guide/index.html):
>Collections are a distribution format for Ansible content that can include playbooks, roles, modules, and plugins

If a collection you use is not a part of the core install, you may need to install it with ansible-galaxy. Example
```
ansible-galaxy collection install community.general
```

The trailing space violations were due to unintentional hitting of space bar or return key. 

This should give us a solid understanding of the structure of a playbook. We can look at a 100 examples which we won't remember. But we can always construct a playbook if we know the basic structure very well. 

We will look at modules next.

## Variable in playbook
Variables can be used in a playbook. They can be declared and referred as follows.

```
- name: Install and start httpd
  hosts: all
  become: true
  vars:
    pkg: httpd
  tasks:
    - name: Install httpd
      package:
        name: "{{ pkg }}" 
        state: present
    - name: Start httpd
      service:
        name: "{{ pkg }}"
        state: started
# We should have pkg within double curly braces.
# For some reason, they are not displayed.
```

## Loop in playbook
To execute the same operation on a series of items, we can use a loop. For example, to create a bunch of users:

```
- name: Create users
  hosts: all
  become: true
  tasks:
    - name: Add several users
      ansible.builtin.user:
        name: "{{ item }}"
        state: present
        groups: "wheel"
      loop: [user1, users2, user3, user4]
# We should have the word item within double curly braces next to name.
# For some reason, they are not displayed.
```

## Modules
Modules are the code that are sent to the remote host for execution. So, we have been using the builtin modules but one can write custom modules.

To use a module, how would one know the options available? Good question. The answer is to use the builtin help.

- `ansible-doc --list` to list the modules
- `ansible-doc <module>` to lookup a module
-  Go the bottom (Shift +G) or search for EXAMPLE
- The options prefixed by = are mandatory. Example - `= name`, `= state` 

## Plugins
Plugins are sort of like modules but unlike modules, they extend the core functionality. We seen plugins like `become` for elevated privilege and `ansible_connection` to state the type of connection to be used. 

For a list of plugins that ship with ansible, see [here](https://docs.ansible.com/ansible/latest/plugins/plugins.html). 


## Facts
We use the package module to install packages on remote host. We can also use distribution specific module like yum or apt. 

When we use package, how does ansible know to use yum or apt? There answer is from facts.

Facts are discovered variables about a system. Every playbook calls the module `setup` automatically to gather useful variables about remote hosts and store them in a special variable called ansible_facts.

To see the facts that ansible gathers on our remote host, we can run this command and grep for CentOS since I know it off hand.

```
ansible all -m ansible.builtin.setup -i inventory | grep CentOS
        "ansible_distribution": "CentOS",
        "ansible_distribution_file_variety": "CentOS",
```

We can also use the `-a` option of the setup module.
```
ansible all -m ansible.builtin.setup -i inventory  -a "filter=ansible_distribution"
```

This way, based on facts, package would learn the target distribution type and calls the appropriate module such as yum or apt. 

The default behavior of ansible is to gather facts. But gathering facts on large number of hosts can slow it down.

If we want to turn it off, there are ways.
- In /etc/ansible/ansible.cfg, add `gathering = explicit`. The default is `gathering = implicit`. 
- To override using environment variable,
`ANSIBLE_GATHERING=explicit`.

If we want to print the facts from a playbook, add a task using the debug module.
```
- name: Print facts
  debug:
    var: gather_facts
```

## Handlers
Handlers is how you execute a task conditionally in Ansible. It doesn't have an if construction. Otherwise, all tasks are executed from top to bottom.

Example - Start httpd only if the install succeeds. 
```
- name: Upgrade and restart httpd
  hosts: all
  become: true
  tasks:
    - name: Install httpd
      package:
        name: httpd
        state: present
      notify:
        - Start httpd
  handlers:
    - name: Start httpd
      service:
        name: httpd
        state: Started
```

More about handlers on the [official doc](https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_handlers.html#naming-handlers).

## Altering behavior
The default config of ansible is documented [here](https://github.com/ansible/ansible/blob/stable-2.9/examples/ansible.cfg).

There are multiple ways to change the default settings. The following is the list of ways to override the default in order of precedence, starting from the lowest.

1. Configuration settings
1. Command-line options
1. Playbook keywords
1. Variables
1. Direct Assignment

Read [more](https://docs.ansible.com/ansible/latest/reference_appendices/general_precedence.html#precedence-categories). 

## List hosts
A couple of ways to list the hosts from the inventory with different patterns.

```
ansible --list-hosts all	
ansible --list-hosts "*"
ansible --list-hosts loadbalancer
ansible --list-hosts webserver
ansible --list-hosts webserver:loadbalancer
ansible --list-hosts webserver[0]
ansible --list-hosts webserver[1]
ansible --list-hosts \!loadbalancer
```
## Validators
- For a pure syntax check on playbook:
    ```
    ansible-playbook --syntax-check <playbook>
    ```
- For syntax checking, suggestions and beyond:
  ```
  ansible-lint <playbook>
  ```

## Check mode
To simulate a playbook without making changes, we can run ansible in check mode

```
ansible-playbook foo.yml --check
OR
ansible-playbook foo.yml --C
```

```
ansible all -m copy -a "content=foo dest=/tmp/bar.txt" -C
```
There is a diff mode as well. You can read about it in the [official doc](https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_checkmode.html#using-check-mode)


## Secrets
To avoid storing sensitive information such as password as plain text in the playbook, Ansible has ansible-vault to encrypt it.

The better approach is to use a dedicated secret manager like HashiCorp Vault or AWS Secrets Manager. Ansible has modules like hashi_vault to fetch secrets from these services.

## Setup CICD
For my [CICI Vagrant box](https://github.com/rualthan/vagrantfiles/tree/main/cicd-jenkins-tomcat), I had a shell scrip to install the packages and configure it. I had Gemini convert the shell script to playbook. It is an interesting observation to see the modules used to perform the equivalent function.  

I ran it through `ansible-playbook --syntax-check` and `ansible-lint`. Both complains not being able to resolve community.general.snap module. Per Gemini, it is not a part of Ansible core install. To fix this:
```
ansible-galaxy collection install community.general
```


